% Функция оценивания частоты и скорости изменения частоты ("df/dt"), а
% также корректировки синхрофазоров.
%
% !!! ВАЖНОЕ ПРИМЕЧАНИЕ.
%
% Поставляемые в функцию синхрофазоры "ph_in" - это синхрофазоры,
% рассчитанные на центр окна, т.е. с применением однопериодного
% центрированного ДПФ, нерекурсивного в том смысле, что каждый синхрофазор
% рассчитывался из "свежего" окна мгновенных значений сигнала, но
% рекурсивного в том смысле, что фаза синхрофазора рассчитывалась
% относительно фазы идеальной синусоиды на частоте 50 Гц (как по C37.118).
% ЭТО ОЧЕНЬ ВАЖНО ЗНАТЬ, ПОСКОЛЬКУ ИСПОЛЬЗУЕМЫЙ ЗДЕСЬ АЛГОРИТМ
% КОРРЕКТИРОВКИ СИНХРОФАЗОРОВ УЧИТЫВАЕТ ЭТО ОБСТОЯТЕЛЬСТВО.



function [ ph_out, f, df_dt ] = ...
Freq_estimation( ph_in, N, dt, alg, phasors_for_freq_track )

% ВХОДНЫЕ ПАРАМЕТРЫ:
%
% 1) ph_in - матрица синхрофазоров, состоящая из 2-х строк и как минимум из
% "2*phasors_for_freq_track+1" столбцов (первая строка - непосредственно
% синхрофазоры, вторая строка - соответствующие им метки времени);
% 2) N - число мгновенных значений (выборок) в одном окне ДПФ;
% 3) dt - интервал времени между выборками (в секундах);
% 4) alg - используемый алгоритм отслеживания частоты и скорости изменения
% частоты: "1" - линейный МНК; "2" - модификация алгоритма, изложенного в
% стандарте C37.118;
% 5) phasors_for_freq_track - количество синхрофазоров в начале и в конце
% 1-й строки "ph_in", не подлежащих коррекции. Если длина строки "ph_in"
% равна "2*phasors_for_freq_track+X", считаем, что можем корректно
% вычислить частоту и "df/dt" только для моментов времени, совпадающих с
% метками времени "X" синхрофазоров, равноудалённых от крайних столбцов
% "ph_in". Соответственно и откорректировать можем лишь эти "X"
% синхрофазоров. Это связано как с длиной окна синхрофазоров, необходимой
% для функционирования алгоритмов оценки частоты и "df/dt", так и с
% дополнительными задержками, вносимыми различными фильтрами. Параметр
% "phasors_for_freq_track" в главной программе мы рассчитываем следующим
% образом:
%
% switch freq_alg
%     case 1
%         phasors_for_freq_track = 2*N + ceil(N/6) + 1;   % с запасом
%     case 2
%         phasors_for_freq_track = ceil( ((N/2-1)-1)/2 ) + ceil(N/6) + 1;   % с запасом
%     otherwise
%         error('   !!! Неизвестный алгоритм отслеживания частоты !!!   ');
% end
%
% ПРИМЕЧАНИЕ. Можно было бы рассчитывать "phasors_for_freq_track"
% непосредственно в этой функции, но задание этого параметра, вычисленного
% один раз, как входного экономит вычислительные ресурсы.

% ВЫХОДНЫЕ ПАРАМЕТРЫ:
%
% 1) ph_out - матрица откорректированных синхрофазоров, число строк которой
% равно 2-м (первая строка - непосредственно синхрофазоры, вторая строка -
% соответствующие им метки времени), а число столбцов меньше на
% "2*phasors_for_freq_track" по сравнению с матрицей "ph_in";
% 2) f - вектор рассчитанных значений частоты с количеством элементов,
% равным числу столбцов в матрице "ph_out". Частота рассчитана для моментов
% времени, совпадающих с метками времени "ph_out";
% 3) df_dt - вектор рассчитанных значений "df_dt" с количеством элементов,
% равным числу столбцов в матрице "ph_out". Значения "df_dt" рассчитаны для
% моментов времени, совпадающих с метками времени "ph_out".



% Выделяем синхрофазоры, подлежащие коррекции, и соответствующие им метки
% времени:
ind_beg = phasors_for_freq_track + 1;   % индекс первого синхрофазора
ind_end = size(ph_in, 2) - phasors_for_freq_track;   % индекс последнего синхрофазора
ph_needed = ph_in(1, ind_beg:ind_end);
time_stamps = ph_in(2, ind_beg:ind_end);

% Определяем количество синхрофазоров, подлежащих коррекции:
num_out = numel(ph_needed);

% Вычисляем частоту и скорость изменения частоты:
switch alg
    
    case 1
        
        % Линейный МНК:
        [f, df_dt] = Algorithm_2(ph_in(1, :), N, dt);
        
        % Мы знаем, что - в соответствии с алгоритмом функции "Algorithm_2"
        % - длина вектора "f" (равно как и "df_dt") на "4*N" меньше длины
        % вектора синхрофазоров "ph_in". Для удобства выделения значений
        % частоты и скорости изменения частоты, которые будем считать
        % корректными, дополним вектора "f" и "df_dt" нулями так, чтобы
        % количество элементов в них было равно таковому в "ph_in":
        to_attach = zeros(1, 2*N);
        f = [ to_attach, f, to_attach ];
        df_dt = [ to_attach, df_dt, to_attach ];
        
    case 2
        
        % Модификация алгоритма, изложенного в стандарте C37.118:
        [f, df_dt] = Algorithm_4_UPDATE(ph_in(1, :), N, dt);
        
        % В данном случае длина вектора "f" (равно как и "df_dt") совпадает
        % с длиной вектора синхрофазоров "ph_in", поэтому нулями дополнять
        % ничего не нужно.
        
end

% Оставляем только те значения частоты и скорости изменения частоты,
% которые будем использовать для корректировки синхрофазоров:
f = f(ind_beg:ind_end);
df_dt = df_dt(ind_beg:ind_end);

% Осуществляем коррекцию синхрофазоров (формулы были выведены ранее):
%
freq_ratio = f / 50;
mult = exp( -2i*(2*pi*50)*time_stamps );
%
P = sin( pi * (freq_ratio - 1) ) ./ ( N * sin( pi * (freq_ratio - 1) / N ) );
Q = sin( pi * (freq_ratio - 1) ) ./ ( N * sin( pi * (freq_ratio - 1) / N + 2 * pi / N ) );
%
% K1_r = real(P); K1_i = 0;   % будем задавать явно (экономим память)
K2_r = real( Q .* mult );
K2_i = imag( Q .* mult );
%
X_est = [ real(ph_needed); imag(ph_needed) ];
X_solved = zeros(size(X_est));
%
for k = 1 : num_out
    K = [   (P(k) + K2_r(k)), K2_i(k);   K2_i(k), (P(k) - K2_r(k))   ];
    X_solved(:, k) = K \ X_est(:, k);
end
%
ph_out = X_solved(1, :) + 1i * X_solved(2, :);
%
ph_out = [ ph_out; time_stamps ];







% -------------------------------------------------------------------------
% Тестирование алгоритма:
% -------------------------------------------------------------------------
%
%
%
% -------
% I. Предварительное тестирование формул коррекции синхрофазоров:
% -------
%
% % Загружаем все переменные из файла "Frequency_estimation_4556.mat".
% 
% 
% 
% % Коэффициенты "P" и "Q":
% P, Q
% P =
%     0.9974
% Q =
%     0.0196
% 
% S1 = [ FAZOR_off_nom_rec([1:2,101:102,end-1:end]); FAZOR_off_nom_rec_err([1:2,101:102,end-1:end]) ]
% S1 =
%   70.7107 +70.7107i  70.3395 +71.0799i  25.8819 +96.5926i  25.3758 +96.7268i  96.3163 -26.8920i  96.4557 -26.3873i
%   71.9118 +69.1378i  71.1264 +69.1893i  24.4269 +94.9517i  23.6053 +95.5007i  94.1632 -26.3335i  94.4984 -25.3461i
% 
% abs(S1)
% ans =
%   100.0000  100.0000  100.0000  100.0000  100.0000  100.0000
%    99.7564   99.2276   98.0434   98.3748   97.7761   97.8385
% 
% angle(S1) * 180/pi
% ans =
%    45.0000   45.3000   75.0000   75.3000  -15.6000  -15.3000
%    43.8734   44.2091   75.5731   76.1162  -15.6241  -15.0143
% 
% % Это фазоры, рассчитанные на центр окна, т.е. с применением центрированного ДПФ,
% % нерекурсивного в том смысле, что каждый синхрофазор рассчитывался из "свежего" окна
% % мгновенных значений, но рекурсивного в том смысле, что фаза синхрофазора рассчитывалась
% % относительно фазы идеальной синусоиды на частоте 50 Гц (как по C37.118).
% 
% % Попробуем восстановить истинные значения ("FAZOR_off_nom_rec") на базе информации
% % об ошибочных значениях ("FAZOR_off_nom_rec_err") и коэффициентах "P" и "Q", используя
% % выведенные ранее формулы.
% 
% % Метки времени синхрофазоров должны быть следующими:
% all_t_stamps = 0 : dt_n : 999*dt_n;
% 
% % Проверим:
% [ all_t_stamps([1:2,101:102,end-1:end]); t_GPS([1:2,101:102,end-1:end]) ]
% ans =
%          0    0.0004    0.0417    0.0421    0.4158    0.4163
%          0    0.0004    0.0417    0.0421    0.4158    0.4163
% 
% % Да.
% 
% K1_r = real(P); K1_i = 0;
% K2_r = real(   Q * exp( -2j*(2*pi*50)*t_GPS )   );
% K2_i = imag(   Q * exp( -2j*(2*pi*50)*t_GPS )   );
% 
% X_est = [ real(FAZOR_off_nom_rec_err); imag(FAZOR_off_nom_rec_err) ];
% X_solved = zeros(size(X_est));
% 
% for k = 1 : 1000
% K = [ (K1_r + K2_r(k)), (K2_i(k) - K1_i); ...
% (K1_i + K2_i(k)), (K1_r - K2_r(k)) ];
% X_solved(:, k) = K \ X_est(:, k);
% end
% X_solved = X_solved(1, :) + j * X_solved(2, :);
% 
% % Сравним рассчитанные (восстановленные) фазоры с истинными:
% 
% S2 = [ FAZOR_off_nom_rec([1:2,101:102,end-1:end]); X_solved([1:2,101:102,end-1:end]) ]
% S2 =
%   70.7107 +70.7107i  70.3395 +71.0799i  25.8819 +96.5926i  25.3758 +96.7268i  96.3163 -26.8920i  96.4557 -26.3873i
%   70.7107 +70.7107i  70.3395 +71.0799i  25.8819 +96.5926i  25.3758 +96.7268i  96.3163 -26.8920i  96.4557 -26.3873i
% 
% abs(S1), abs(S2)
% ans =
%   100.0000  100.0000  100.0000  100.0000  100.0000  100.0000
%    99.7564   99.2276   98.0434   98.3748   97.7761   97.8385
% ans =
%   100.0000  100.0000  100.0000  100.0000  100.0000  100.0000
%   100.0000  100.0000  100.0000  100.0000  100.0000  100.0000
% 
% angle(S1) * 180/pi, angle(S2) * 180/pi
% ans =
%    45.0000   45.3000   75.0000   75.3000  -15.6000  -15.3000
%    43.8734   44.2091   75.5731   76.1162  -15.6241  -15.0143
% ans =
%    45.0000   45.3000   75.0000   75.3000  -15.6000  -15.3000
%    45.0000   45.3000   75.0000   75.3000  -15.6000  -15.3000
% 
% % Да, всё верно.
% 
% % Итак, если знаем реальную частоту, соответствующую каждому фазору,
% % можем динамически вычислять коэффициенты "P" и "Q", на этой основе формировать
% % матрицу "K" и корректировать каждый фазор в отдельности.
% 
% % Сложности могут возникнуть при наличии высших гармоник, изменяющейся частоты, "шума".
%
%
%
% -------
% II. Тестирование всего алгоритма:
% -------
%
% % Загружаем все переменные из файла "Frequency_estimation_4556.mat".
% 
% 
% 
% % --- 1.1. Сигнал на частоте 52 Гц; алгоритм 1 (линейный МНК). ---
% 
% 
% N
% N =
%     48
% phasors_for_freq_track = 2*N + ceil(N/6) + 1
% phasors_for_freq_track =
%    105
% 
% ph_in = [ FAZOR_off_nom_rec_err; t_GPS ];
% 
% % Количество синхрофазоров, которые мы должны откорректировать:
% [ numel(t_GPS) - 2*phasors_for_freq_track, size(ph_in, 2) - 2*phasors_for_freq_track ]
% ans =
%    790   790
% 
% [ ph_out, f, df_dt ] = Freq_estimation( ph_in, N, dt_n, 1, phasors_for_freq_track );
% 
% % Проверяем размерности выходных переменных:
% [ size(ph_out), size(f), size(df_dt) ]
% ans =
%      2   790     1   790     1   790
% 
% % Верно.
% 
% % Выделяем порцию эталонных синхрофазоров и меток времени:
% ind_beg = phasors_for_freq_track + 1;   % индекс первого синхрофазора
% ind_end = size(ph_in, 2) - phasors_for_freq_track;   % индекс последнего синхрофазора
% ph_true = FAZOR_off_nom_rec(ind_beg:ind_end);
% time_stamps = t_GPS(ind_beg:ind_end);
% 
% % Выделяем также порцию ошибочных синхрофазоров для сравнения:
% ph_err = FAZOR_off_nom_rec_err(ind_beg:ind_end);
% 
% % Сравниваем:
% 
% S = [ ph_true([1:2,101:102,end-1:end]); ph_out(1, [1:2,101:102,end-1:end]); ...
% ph_err([1:2,101:102,end-1:end]) ]
% S =
%   23.3445 +97.2370i  22.8351 +97.3579i -28.4015 +95.8820i -28.9032 +95.7319i  68.0721 -73.2543i  68.4547 -72.8969i
%   23.3445 +97.2370i  22.8350 +97.3579i -28.4015 +95.8820i -28.9031 +95.7320i  68.0722 -73.2543i  68.4548 -72.8969i
%   21.6108 +98.0062i  21.4324 +98.5318i -27.3020 +97.3023i -27.3974 +96.8230i  69.6266 -73.9795i  69.7046 -74.0479i
% 
% % Практически идеальное совпадение первых двух строк!
% 
% abs(S)
% ans =
%   100.0000  100.0000  100.0000  100.0000  100.0000  100.0000
%   100.0000  100.0000  100.0000  100.0000  100.0001  100.0001
%   100.3606  100.8358  101.0601  100.6246  101.5915  101.6948
% 
% angle(S) * 180/pi
% ans =
%    76.5000   76.8000  106.5000  106.8000  -47.1000  -46.8000
%    76.5000   76.8000  106.5000  106.8000  -47.1000  -46.8000
%    77.5650   77.7283  105.6736  105.7996  -46.7362  -46.7306
% 
% % Замечательно!
% 
% % Это означает, что частота отслеживается корректно.
% % Убедимся в этом:
% f([1:2,101:102,end-1:end])
% ans =
%    51.9999   51.9999   51.9999   51.9999   51.9999   51.9998
% [ min(f), mean(f), max(f) ]
% ans =
%    51.9998   52.0000   52.0002
% 
% % Посмотрим, насколько корректно оценивалась скорость изменения частоты (равная нулю):
% df_dt([1:2,101:102,end-1:end])
% ans =
%    -0.0476   -0.0418    0.0374    0.0449   -0.0166   -0.0032
% [ min(df_dt), mean(df_dt), max(df_dt) ]
% ans =
%    -0.0498   -0.0002    0.0498
% 
% % Скорость изменения частоты, как мы знаем, оценить не так просто.
% 
% 
% % --- 1.2. Сигнал на частоте 52 Гц; алгоритм 2 (модификация алгоритма в C37.118). ---
% 
% 
% phasors_for_freq_track = ceil( ((N/2-1)-1)/2 ) + ceil(N/6) + 1
% phasors_for_freq_track =
%     20
% 
% % Количество синхрофазоров, которые мы должны откорректировать:
% [ numel(t_GPS) - 2*phasors_for_freq_track, size(ph_in, 2) - 2*phasors_for_freq_track ]
% ans =
%    960   960
% 
% [ ph_out, f, df_dt ] = Freq_estimation( ph_in, N, dt_n, 2, phasors_for_freq_track );
% 
% % Проверяем размерности выходных переменных:
% [ size(ph_out), size(f), size(df_dt) ]
% ans =
%      2   960     1   960     1   960
% 
% % Верно.
% 
% % Выделяем порцию эталонных синхрофазоров и меток времени:
% ind_beg = phasors_for_freq_track + 1;   % индекс первого синхрофазора
% ind_end = size(ph_in, 2) - phasors_for_freq_track;   % индекс последнего синхрофазора
% ph_true = FAZOR_off_nom_rec(ind_beg:ind_end);
% time_stamps = t_GPS(ind_beg:ind_end);
% 
% % Выделяем также порцию ошибочных синхрофазоров для сравнения:
% ph_err = FAZOR_off_nom_rec_err(ind_beg:ind_end);
% 
% % Сравниваем:
% 
% S = [ ph_true([1:2,101:102,end-1:end]); ph_out(1, [1:2,101:102,end-1:end]); ...
% ph_err([1:2,101:102,end-1:end]) ]
% S =
%   62.9320 +77.7146i  62.5243 +78.0430i  15.6434 +98.7688i  15.1261 +98.8494i  92.9776 -36.8125i  93.1691 -36.3251i
%   62.9319 +77.7146i  62.5241 +78.0431i  15.6435 +98.7684i  15.1260 +98.8490i  92.9775 -36.8122i  93.1691 -36.3250i
%   64.7039 +77.8171i  64.3095 +77.6227i  15.9092 +96.5719i  14.8711 +96.6399i  92.0112 -34.8920i  92.7090 -34.2800i
% 
% abs(S)
% ans =
%   100.0000  100.0000  100.0000  100.0000  100.0000  100.0000
%    99.9999  100.0000   99.9996   99.9996   99.9998   99.9999
%   101.2033  100.8017   97.8736   97.7774   98.4048   98.8437
% 
% angle(S) * 180/pi
% ans =
%    51.0000   51.3000   81.0000   81.3000  -21.6000  -21.3000
%    51.0001   51.3001   80.9999   81.3000  -21.5999  -21.2999
%    50.2569   50.3586   80.6452   81.2519  -20.7675  -20.2924
% 
% % Очень и очень неплохо!
% 
% % Посмотрим, насколько корректно оценивалась частота:
% f([1:2,101:102,end-1:end])
% ans =
%    52.0002   52.0002   51.9997   51.9997   51.9998   51.9999
% [ min(f), mean(f), max(f) ]
% ans =
%    51.9997   52.0000   52.0003
% 
% % Посмотрим, насколько корректно оценивалась скорость изменения частоты (равная нулю):
% df_dt([1:2,101:102,end-1:end])
% ans =
%    -0.1191   -0.1609   -0.0712   -0.0096    0.1675    0.2012
% [ min(df_dt), mean(df_dt), max(df_dt) ]
% ans =
%    -0.2174   -0.0009    0.2174
% 
% % Ничего удивительного. Мы осведомлены о подобном поведении.
% % При использовании алгоритма 2 (модификация алгоритма в C37.118) просто нужен ещё один
% % фильтр скользящего среднего (уже по вычисленным значениям "df_dt"), который можно
% % организовать не внутри PMU, а на верхнем уровне иерархии.
% 
% 
% % --- 2.1. Сигнал с начальной частотой 52 Гц и "df/dt" в 1 Гц/с; алгоритм 1 (линейный МНК). ---
% 
% 
% % Для этого сигнала у нас, кажется, пока не вычислены эталонные синхрофазоры.
% % Сделаем это:
% FAZOR_freq_change = 100 * exp(1i*ANGLE_3_TRUE_1000*pi/180);
% 
% phasors_for_freq_track = 2*N + ceil(N/6) + 1;
% 
% ph_in = [ FAZOR_3; t_GPS ];
% 
% % Количество синхрофазоров, которые мы должны откорректировать:
% [ numel(t_GPS) - 2*phasors_for_freq_track, size(ph_in, 2) - 2*phasors_for_freq_track ]
% ans =
%    790   790
% 
% [ ph_out, f, df_dt ] = Freq_estimation( ph_in, N, dt_n, 1, phasors_for_freq_track );
% 
% % Проверяем размерности выходных переменных:
% [ size(ph_out), size(f), size(df_dt) ]
% ans =
%      2   790     1   790     1   790
% 
% % Верно.
% 
% % Выделяем порцию эталонных синхрофазоров и меток времени:
% ind_beg = phasors_for_freq_track + 1;   % индекс первого синхрофазора
% ind_end = size(ph_in, 2) - phasors_for_freq_track;   % индекс последнего синхрофазора
% ph_true = FAZOR_freq_change(ind_beg:ind_end);
% time_stamps = t_GPS(ind_beg:ind_end);
% 
% % Выделяем также порцию ошибочных синхрофазоров для сравнения:
% ph_err = FAZOR_3(ind_beg:ind_end);
% 
% % Сравниваем:
% 
% S = [ ph_true([1:2,101:102,end-1:end]); ph_out(1, [1:2,101:102,end-1:end]); ...
% ph_err([1:2,101:102,end-1:end]) ]
% S =
%   22.7594 +97.3756i  22.2380 +97.4960i -30.5916 +95.2058i -31.1110 +95.0374i  92.6004 -37.7513i  92.8331 -37.1755i
%   22.7502 +97.3796i  22.2292 +97.4997i -30.5998 +95.2017i -31.1195 +95.0328i  92.6028 -37.7429i  92.8351 -37.1666i
%   20.9862 +98.1694i  20.8057 +98.7010i -29.4052 +96.6465i -29.5089 +96.1249i  93.6596 -39.4483i  93.3526 -39.1791i
% 
% abs(S)
% ans =
%   100.0000  100.0000  100.0000  100.0000  100.0000  100.0000
%   100.0018  100.0016   99.9985   99.9983   99.9990   99.9986
%   100.3875  100.8701  101.0208  100.5523  101.6282  101.2408
% 
% angle(S) * 180/pi
% ans =
%    76.8445   77.1511  107.8133  108.1261  -22.1797  -21.8239
%    76.8502   77.1565  107.8185  108.1316  -22.1748  -21.8187
%    77.9332   78.0966  106.9226  107.0657  -22.8402  -22.7673
% 
% % Восстановленные значения очень близки к истинным, что радует!
% 
% % Сравним также метки времени (они должны совпадать идеально):
% [ time_stamps([1:2,101:102,end-1:end]); ph_out(2, [1:2,101:102,end-1:end]) ]
% ans =
%     0.0438    0.0442    0.0854    0.0858    0.3721    0.3725
%     0.0438    0.0442    0.0854    0.0858    0.3721    0.3725
% 
% % Да, верно.
% 
% % Выделим теперь порцию эталонных значений частоты:
% freq_true = FREQ_3_TRUE_1000(ind_beg:ind_end);
% 
% % Сопоставим с рассчитанными значениями:
% [ freq_true([1:2,101:102,end-1:end]); f([1:2,101:102,end-1:end]) ]
% ans =
%    52.0438   52.0442   52.0854   52.0858   52.3721   52.3725
%    52.0437   52.0441   52.0853   52.0858   52.3720   52.3724
% 
% % Очень близкие совпадения!
% 
% [ min(freq_true-f), mean(freq_true-f), max(freq_true-f) ]
% ans =
%    1.0e-03 *
%    -0.1618    0.0012    0.1557
% 
% % Отличия в четвёртом знаке после запятой.
% 
% % Посмотрим, насколько корректно оценивалась скорость изменения частоты (равная 1 Гц/с):
% df_dt([1:2,101:102,end-1:end])
% ans =
%     0.9499    0.9559    1.0422    1.0500    1.0368    1.0523
% [ min(1-df_dt), mean(1-df_dt), max(1-df_dt) ]
% ans =
%    -0.0713    0.0002    0.0714
% 
% % Скорость изменения частоты, как мы знаем, оценить не так просто.
% % Результат для этого алгоритма и для этого сигнала ожидаемый.
% 
% 
% % --- 2.2. Сигнал с начальной частотой 52 Гц и "df/dt" в 1 Гц/с; алгоритм 2 (C37.118). ---
% 
% 
% phasors_for_freq_track = ceil( ((N/2-1)-1)/2 ) + ceil(N/6) + 1;
% 
% ph_in = [ FAZOR_3; t_GPS ];
% 
% % Количество синхрофазоров, которые мы должны откорректировать:
% [ numel(t_GPS) - 2*phasors_for_freq_track, size(ph_in, 2) - 2*phasors_for_freq_track ]
% ans =
%    960   960
% 
% [ ph_out, f, df_dt ] = Freq_estimation( ph_in, N, dt_n, 2, phasors_for_freq_track );
% 
% % Проверяем размерности выходных переменных:
% [ size(ph_out), size(f), size(df_dt) ]
% ans =
%      2   960     1   960     1   960
% 
% % Верно.
% 
% % Выделяем порцию эталонных синхрофазоров и меток времени:
% ind_beg = phasors_for_freq_track + 1;   % индекс первого синхрофазора
% ind_end = size(ph_in, 2) - phasors_for_freq_track;   % индекс последнего синхрофазора
% ph_true = FAZOR_freq_change(ind_beg:ind_end);
% time_stamps = t_GPS(ind_beg:ind_end);
% 
% % Выделяем также порцию ошибочных синхрофазоров для сравнения:
% ph_err = FAZOR_3(ind_beg:ind_end);
% 
% % Сравниваем:
% 
% S = [ ph_true([1:2,101:102,end-1:end]); ph_out(1, [1:2,101:102,end-1:end]); ...
% ph_err([1:2,101:102,end-1:end]) ]
% S =
%   62.9151 +77.7283i  62.5055 +78.0581i  14.8672 +98.8887i  14.3362 +98.9670i  98.9551 +14.4186i  98.8622 +15.0420i
%   62.9072 +77.7330i  62.4971 +78.0627i  14.8551 +98.8896i  14.3240 +98.9684i  98.9555 +14.4286i  98.8625 +15.0517i
%   64.6858 +77.8344i  64.2893 +77.6389i  15.1125 +96.6299i  14.0478 +96.6997i  98.9176 +16.6981i  99.4286 +17.1462i
% 
% abs(S)
% ans =
%   100.0000  100.0000  100.0000  100.0000  100.0000  100.0000
%    99.9987   99.9984   99.9991   99.9996  100.0019  100.0017
%   101.2050  100.8013   97.8045   97.7147  100.3171  100.8962
% 
% angle(S) * 180/pi
% ans =
%    51.0125   51.3138   81.4500   81.7575    8.2901    8.6513
%    51.0177   51.3192   81.4570   81.7646    8.2958    8.6567
%    50.2711   50.3734   81.1112   81.7343    9.5816    9.7843
% 
% % По углам отличия только во втором знаке после запятой.
% % С амплитудами тоже всё верно.
% % Таким образом, восстановленные значения очень близки к истинным, что радует!
% 
% % Сравним также метки времени (они должны совпадать идеально):
% [ time_stamps([1:2,101:102,end-1:end]); ph_out(2, [1:2,101:102,end-1:end]) ]
% ans =
%     0.0083    0.0088    0.0500    0.0504    0.4075    0.4079
%     0.0083    0.0088    0.0500    0.0504    0.4075    0.4079
% 
% % Да, верно.
% 
% % Выделим теперь порцию эталонных значений частоты:
% freq_true = FREQ_3_TRUE_1000(ind_beg:ind_end);
% 
% % Сопоставим с рассчитанными значениями:
% [ freq_true([1:2,101:102,end-1:end]); f([1:2,101:102,end-1:end]) ]
% ans =
%    52.0083   52.0087   52.0500   52.0504   52.4075   52.4079
%    52.0085   52.0088   52.0497   52.0502   52.4075   52.4077
% 
% % Отличия лишь примерно в 0,0002-0,0003 Гц!
% 
% [ min(freq_true-f), mean(freq_true-f), max(freq_true-f) ]
% ans =
%    1.0e-03 *
%    -0.6572   -0.0011    0.5881
% 
% % Посмотрим, насколько корректно оценивалась скорость изменения частоты (равная 1 Гц/с):
% df_dt([1:2,101:102,end-1:end])
% ans =
%     0.8171    0.7929    1.0446    1.0958    0.5808    0.6234
% [ min(1-df_dt), mean(1-df_dt), max(1-df_dt) ]
% ans =
%    -0.4416    0.0012    0.4287
% 
% % Опять же - ничего удивительного для этого алгоритма.
% % Здесь нужна дополнительная фильтрация по рассчитанным значениям "df_dt",
% % например:
% df_dt_aver = Moving_average(df_dt, N/2-1);
% 
% df_dt_aver([1:2,101:102,end-1:end])
% ans =
%     0.8171    0.7972    0.9986    0.9986    0.5918    0.6234
% df_dt_aver(301:310)
% ans =
%     1.0013    1.0009    1.0003    0.9998    0.9993    0.9988    0.9985    0.9983    0.9982    0.9981
