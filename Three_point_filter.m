% Реализация трёхточечного фильтра для сглаживания колебаний магнитуды или
% фазового угла синхрофазоров, получающихся при применении ДПФ,
% "заточенного" под номинальную частоту, к сигналу с неноминальной
% частотой.
% Идея взята из раздела 3.3.1 в книге "Synchronized Phasor Measurements and
% Their Applications".

function out = Three_point_filter(in, N, flag)

% ВХОДНЫЕ ПАРАМЕТРЫ:
%
% 1) "in" - сигнал, содержащий последовательные рассчитанные значения
% магнитуд или фаз синхрофазоров;
% 2) "N" - число выборок на период (оно же - число синхрофазоров на период
% номинальной частоты сигнала);
% 3) "flag" - логическая переменная: "true" означает, что входной сигнал
% "in" содержит магнитуды; "false" означает, что он содержит фазовые углы
% синхрофазоров; другие варианты невозможны.

% ВЫХОДНОЙ ПАРАМЕТР:
%
% "out" - отфильтрованный сигнал.

% ВАЖНО: для фазовых углов величины должны быть представлены в градусах.
% Внутри алгоритма пересчёт из радиан в градусы не осуществляется.



% Проверяем, достаточно ли количество элементов в массиве (работать с
% меньшим количеством, чем "N/2", особого смысла не имеет):
num = numel(in);
if num < (N/2)
    error('Слишком мало элементов!');
end

% Округляем число "N/6", необходимое алгоритму, до ближайшего целого:
N_ro = round(N/6);

% Выходной сигнал (пока все его элементы равны соответствующим элементам
% входного сигнала):
out = in;

if flag   % алгоритм для магнитуд
    
    for k = (N_ro + 1) : (num - N_ro)
        out(k) = mean( [in(k-N_ro), in(k), in(k+N_ro)] );
    end
    
else   % алгоритм для фазовых углов
    
    for k = (N_ro + 1) : (num - N_ro)
        
        % При фильтрации угловых величин крайне важно учесть "перескоки" с
        % -180 градусов на +180 градусов (или в обратном направлении);
        % истинный знак задаёт центральная усредняемая точка, определяемая
        % "in(k)".
        
        p1 = in(k-N_ro);
        p2 = in(k);
        p3 = in(k+N_ro);
        
        % Проверяем соотношение знаков для "p1" и "p2", а также для "p3" и
        % "p2". Вместо двух различных "if", можно использовать одно "if"
        % вместе с "elseif", поскольку "прыжок" по фазе может быть или
        % только слева от центральной точки "p2", или только справа от неё:
        if abs(p1 - p2) > 180 % на самом деле, там будет не просто
                              % что-то большее 180, а близкое к 360
            if p2 < 0
                p1 = p1 - 360;
            else
                p1 = p1 + 360;
            end
        elseif abs(p3 - p2) > 180 % на самом деле, там будет не просто
                                  % что-то большее 180, а близкое к 360
            if p2 < 0
                p3 = p3 - 360;
            else
                p3 = p3 + 360;
            end
        end
        
        out(k) = mean( [p1, p2, p3] );
        
    end
    
end
