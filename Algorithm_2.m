% Алгоритм № 2 для оценки частоты и скорости изменения частоты: оценка
% частоты и скорости изменения частоты на основе линейной регрессии (метод
% наименьших квадратов, МНК).
%
% Источник: Chapter 4 "Frequency Estimation" в "Synchronized Phasor
% Measurements and Their Applications".
%
% !!! ВАЖНОЕ ПРИМЕЧАНИЕ.
%
% Будем использовать модификацию этого алгоритма (формулы выведены на
% бумаге), такую что значение частоты сигнала оценивается не на начало, а
% на центр окна, состоящего из "4*N+1" последовательных синхрофазоров.
% Центр окна (его метка времени) располагается строго посередине между
% первыми "2*N" синхрофазорами и последними "2*N" синхрофазорами, т.е.
% совпадает с "2*N+1"-м синхрофазором.



function [ F, DF ] = Algorithm_2 ( Sig, N, dt )

% Входные переменные:
%
% 1) "Sig" - вектор последовательно вычисленных синхрофазоров;
% 2) "N" - число выборок на период при дискретизации входного аналогового
% сигнала;
% 3) "dt" - интервал времени между соседними синхрофазорами; этот интервал
% должен соответствовать "dt = 1 / (N * 50)", но задаём его явно, чтобы не
% тратить зря вычислительные ресурсы при итеративном исполнении главного
% кода, в который входит эта функция.

% Выходные переменные:
%
% 1) "F" - вектор рассчитанных значений частоты сигнала (в Гц). Длина
% вектора на "4*N" меньше длины вектора синхрофазоров "Sig". Это
% определяется тем, что для функционирования алгоритма нами используется
% окно длиной "4*N+1", поэтому первое значение частоты может быть
% определено только при наличии "2*N" значений синхрофазоров "слева", а для
% последнего значения частоты должно быть "2*N" значений синхрофазоров
% "справа";
% 2) "DF" - вектор рассчитанных значений скорости изменения частоты сигнала
% (в Гц/с). Длина вектора также на "4*N" меньше длины вектора синхрофазоров
% "Sig".

% !!! ВАЖНОЕ ПРИМЕЧАНИЕ.
%
% Первые значения частоты вряд ли окажутся корректными. Необходимо учесть
% задержку, вносимую трёхточечным фильтром ("Three_point_filter" - см.
% ниже) и приблизительно равную "round(N/6)". То же самое касается и
% последних значений частоты.

% !!! ВАЖНОЕ ПРИМЕЧАНИЕ.
%
% Полагаем, что длина сигнала "Sig" составляет как минимум "4*N+1"
% элементов, поэтому специально проверять этот факт ("выбрасывать" ошибку)
% не будем.



% Вычисляем фазовые углы для входного массива синхрофазоров:
Ang = angle(Sig) * 180/pi;   % в градусах

% Применяем трёхточечный фильтр:
Ang = Three_point_filter(Ang, N, false);

% Избавляемся от возможных "скачков" угла в районе 180 градусов:
Ang = No_angle_jumps(Ang);

% Переводим углы в радианы и транспонируем вектор:
Ang = Ang' * pi/180;   % в радианах

% Ang = (Moving_average(Ang, N/2-1))';

% Определяем размерность выходных переменных:
num_of_elem = numel(Sig) - 4*N;
F = zeros(1, num_of_elem);
DF = zeros(1, num_of_elem);

% Задаём момент времени, для которого вычисляется частота:
t0 = 2*N*dt;

% Задаём матрицу "B":
B = zeros(4*N+1, 3);
B(:, 1) = 1;
B(:, 2) = dt * (0 : (4*N));
B(:, 3) = dt^2 * (0 : (4*N)).^2;

% Задаём матрицу "G":
G = (B' * B) \ B';

% Получаем вектор "A" и генерируем выходные данные:
for k = 1 : num_of_elem
    A = G * Ang( k : (4*N+k) );
    deriv = A(3) / pi;
    freq = 50 + ( A(2) + 2*pi*deriv*t0 ) / (2*pi);
    F(k) = freq;
    DF(k) = deriv;
end