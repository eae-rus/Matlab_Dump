% Алгоритм № 4 для оценки частоты и скорости изменения частоты: оценка
% частоты и скорости изменения частоты как производных фазового угла.
%
% Источник: IEEE Std C37.118.1a-2014 «IEEE Standard for Synchrophasor
% Measurements for Power Systems», Amendment 1: Modification of Selected
% Performance Requirements.
%
% !!! ВАЖНОЕ ПРИМЕЧАНИЕ.
%
% Будем использовать модификацию алгоритма, а именно - дополнительно
% "выпрямлять" фазовые углы синхрофазоров с помощью фильтра скользящего
% среднего длиной "N/2-1" или "N/2" (см. ниже).



function [ F, DF ] = Algorithm_4_UPDATE ( Sig, N, dt )

% Входные переменные:
%
% 1) "Sig" - вектор последовательно вычисленных синхрофазоров;
% 2) "N" - число выборок на период при дискретизации входного аналогового
% сигнала;
% 3) "dt" - интервал времени между соседними синхрофазорами; этот интервал
% должен соответствовать "dt = 1 / (N * 50)", но задаём его явно, чтобы не
% тратить зря вычислительные ресурсы при итеративном исполнении главного
% кода, в который входит эта функция.

% Выходные переменные:
%
% 1) "F" - вектор рассчитанных значений частоты сигнала (в Гц). Длина
% вектора равна длине вектора синхрофазоров "Sig";
% 2) "DF" - вектор рассчитанных значений скорости изменения частоты сигнала
% (в Гц/с). Длина вектора также равна длине вектора синхрофазоров "Sig".

% !!! ВАЖНОЕ ПРИМЕЧАНИЕ.
%
% Число выборок на период "N" должно быть чётным.

% !!! ВАЖНОЕ ПРИМЕЧАНИЕ.
%
% Первые значения частоты вряд ли окажутся корректными. Необходимо учесть
% задержку, вносимую трёхточечным фильтром ("Three_point_filter" - см.
% ниже) и приблизительно равную "round(N/6)", а также задержку, вносимую
% фильтром скользящего среднего ("Moving_average" - см. ниже) и
% приблизительно равную "((N/2-1)-1)/2" или "((N/2)-1)/2" (см. объяснения и
% примеры ниже). То же самое касается и последних значений частоты. Для
% первых и последних значений скорости изменения частоты - аналогично.

% !!! ВАЖНОЕ ПРИМЕЧАНИЕ.
%
% Полагаем, что длина сигнала "Sig" вполне достаточна для корректного
% функционирования алгоритма, поэтому специально проверять этот факт
% ("выбрасывать" ошибку) не будем.

% !!! ВАЖНОЕ ПРИМЕЧАНИЕ.
%
% Первый и последний элементы вектора "F" (равно как и "DF") будут равны
% нулю, поскольку - в соответствии с используемым алгоритмом - значения
% этих элементов рассчитать невозможно.



% Определяем точную длину фильтра скользящего среднего ("Moving_average"),
% которую будем использовать:
filter_length = 2 * floor((N/2-1)/2) + 1;
%
% ПРИМЕЧАНИЕ 1. Дело в том, что окно для фильтра "Moving_average" должно
% содержать нечётное количество значений. По условию входной параметр "N" -
% число чётное, однако нет никакой гарантии, что чётным будет и "N/2".
% Примеры:
%
% 1. N = 48 (делится на 4).
%
% Длина фильтра скользящего среднего:
% N = 48;
% [ 2 * floor((N/2-1)/2) + 1,   N/2-1 ]
% ans =
%     23    23
%
% Вносимая фильтром задержка:
% [ (ans(1)-1)/2, ((N/2-1)-1)/2 ]
% ans =
%     11    11
%
% 2. N = 50 (не делится нацело на 4).
%
% Длина фильтра скользящего среднего:
% N = 50;
% [ 2 * floor((N/2-1)/2) + 1,   N/2 ]
% ans =
%     25    25
%
% Вносимая фильтром задержка:
% [ (ans(1)-1)/2, ((N/2)-1)/2 ]
% ans =
%     12    12
%
% ПРИМЕЧАНИЕ 2. При итеративном исполнении данной функции (имитация
% функционирования PMU) переменную "filter_length" лучше бы вычислять
% заранее и поставлять в эту функцию как входной параметр, чтобы экономить
% вычислительные ресурсы.

% Вычисляем фазовые углы для входного массива синхрофазоров:
Ang = angle(Sig) * 180/pi;   % в градусах

% Применяем трёхточечный фильтр:
Ang = Three_point_filter(Ang, N, false);

% Избавляемся от возможных "скачков" угла в районе 180 градусов:
Ang = No_angle_jumps(Ang);

% Переводим углы в радианы:
Ang = Ang * pi/180;

% Реализуем дополнительное "выпрямление" фазовых углов:
Ang = Moving_average(Ang, filter_length);

% Определяем размерность выходных переменных:
num_of_elem = numel(Sig);   % количество синхрофазоров с метками времени
F = zeros(1, num_of_elem);
DF = zeros(1, num_of_elem);

% Отметим, что поскольку реализация базового алгоритма предполагает знание
% фазовых углов синхрофазоров "(i-1)" и "(i+1)", т.е. "прошлого" и
% "будущего", крайние элементы векторов "F" и "DF" будут равны нулю,
% поскольку соответствующие значения элементов рассчитать невозможно.

% Реализуем базовый алгоритм оценки частоты и скорости изменения частоты:
a1 = (4*pi*dt);   % вспомогательная переменная 1
a2 = (2*pi*dt^2);   % вспомогательная переменная 2
for k = 2 : (num_of_elem-1)
    F(k) = 50 + ( Ang(k+1) - Ang(k-1) ) / a1;
    DF(k) = ( Ang(k+1) + Ang(k-1) - 2 * Ang(k) ) / a2;
end
