%% Нелинейный расчет частоты
%% Модели сигналов и вспомогательная информация
%%
% Амплитуда
A_true = 100 * sqrt(2);
%%
% Число выборок за период
N=256;
%%
% Угловая скорость
omega0 = 25 * 2 * pi;
%%
% Получаем метки времени
t = 0 : (1/(N*50)) : (0.2-(1/(N*50)));
%%
% Изменение частоты от номинальной
d_omega_true = 0 * 2 * pi;
%%
% Скорость изменения частоты 
d_omega_dt_true = 0 * 2 * pi;
%%
% Начальная фаза сигнала
fi_0_true = pi/4;
%%
% Получаем выборки (приходят с АЦП)
x_true = A_true * cos(fi_0_true + omega0 * t + d_omega_true * t + 0.5 * d_omega_dt_true * t.^2);

%%
% Задаемся начальным вектором Z
Z = [100 0 0 0]';
%%
% Считаем разницу сигнала для начального вектора Z

signal_diff =(  Z(1) * cos(Z(2) + omega0 * t + Z(3) * t + 0.5 * Z(4) * t.^2) - x_true  );


%% Цикл итераций 
%%

% Определим якобиан как handle функцию:

Jacobian = @ (Z1,Z2,Z3,Z4) ([  cos(Z2 + omega0 * t + Z3 * t + 0.5 * Z4 * t.^2); ...
-Z1 * sin(Z2 + omega0 * t + Z3 * t + 0.5 * Z4 * t.^2); ...
-Z1 * t .* sin(Z2 + omega0 * t + Z3 * t + 0.5 * Z4 * t.^2); ...
-Z1 * 0.5 * t.^2 .* sin(Z2 + omega0 * t + Z3 * t + 0.5 * Z4 * t.^2)  ].');

% Непосредственно итерации

p=0;

while (norm(signal_diff)>=0.01)&&(p<100)

Delta_Z = inv((Jacobian(Z(1),Z(2),Z(3),Z(4)))' * (Jacobian(Z(1),Z(2),Z(3),Z(4)))) * (Jacobian(Z(1),Z(2),Z(3),Z(4)))' * signal_diff'; 

Z=Z-Delta_Z;  

signal_diff =(  Z(1) * cos(Z(2) + omega0 * t + Z(3) * t + 0.5 * Z(4) * t.^2) - x_true  );

p=p+1;

end

%% Вычисление частоты
%%
% Вычисляем частоту

frq=50+((Z(3))/(2*pi));

frq_speed=Z(4)/(2*pi);
