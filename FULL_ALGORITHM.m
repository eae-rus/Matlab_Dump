% Попытка имитации функционирования УСВИ в динамике (пока без фильтра
% "anti-aliasing", т.е. с использованием простого прямоугольного окна при
% реализации "оконного" ДПФ).
%
% ОСОБЕННОСТИ:
%
% 1) три различных модели сигнала ("чистая" синусоида; синусоида с третьей
% гармоникой; сигнал с увеличивающейся частотой);
% 2) два алгоритма отслеживания частоты сигнала (линейный метод наименьших
% квадратов (МНК) - алгоритм 2 в нашей таблице; модификация алгоритма,
% изложенного в стандарте C37.118, - алгоритм 4 в нашей таблице);
% 3) однопериодное ДПФ (нерекурсивное, центрированное);
% 4) считаем, что отсчёт фазового угла начинается в момент времени t = 0,
% т.е. фаза "опорной" косинусоиды равна нулю именно в этот момент времени.
% В реальности же необходимо будет сначала зафиксировать этот момент
% времени посредством приёма сигнала "1pps". Метки времени, присваиваемые
% всем синхрофазорам, также относительные (показывают, сколько времени в
% секундах прошло с начала отсчёта t = 0);
% 5) определение искомых параметров (синхрофазоров, частоты и скорости
% изменения частоты) и расчёт соответствующих погрешностей не только для
% моментов времени, требуемых для агрегации данных на верхнем уровне
% иерархии (см. "t_GPS = time_stamp_1 : dt_GPS : full_time;"), но и для
% моментов времени, для которых эти параметры могут вычисляться "внутри"
% УСВИ (см. "t_all_raw = 0 : dt : full_time;"
% и "t_all = (dt_decim - dt) : dt_decim : full_time;").



%%
% -------------------------------------------------------------------------
% I. Ввод всех исходных данных.
% -------------------------------------------------------------------------



% Задание модели сигнала:
disp(' ');
prompt = [ 'Введите номер модели сигнала:', ...
           '\n1 - "чистая" синусоида;', ...
           '\n2 - синусоида с третьей гармоникой;', ...
           '\n3 - сигнал с увеличивающейся частотой:   ' ];
which_signal = input(prompt);
disp(' ');


% Задание частоты основной гармоники сигнала (для сигнала с изменяющейся
% частотой - частоты для начального момента времени t = 0):
prompt = [ 'Задайте значение частоты основной гармоники сигнала, Гц', ...
           '\n(для сигнала с увеличивающейся частотой -', ...
           '\nчастоты в момент времени t = 0):   ' ];
freq = input(prompt);
disp(' ');


% Задание амплитуды сигнала:
A = input('Задайте амплитуду сигнала, В:   ');
disp(' ');


% Задание начальной фазы косинусоиды
% (под "косинусоидой" будем понимать и сигнал с изменяющейся частотой;
% просто имеется в виду, что изменения сигнала происходят по закону
% косинуса, а не синуса, т.е. в начальный момент времени для основной
% гармоники имеем "A*cos(fi)" при отсутствии "шума"):
fi = input('Задайте начальную фазу косинусоиды (при t = 0), рад:   ');
disp(' ');


if which_signal == 2
    
    % Задание амплитуды третьей гармоники:
    A3 = input('Введите амплитуду третьей гармоники, В:   ');
    disp(' ');
    
elseif which_signal == 3
    
    % Задание скорости изменения частоты:
    df_dt = input('Задайте скорость изменения частоты сигнала, Гц/с:   ');
    disp(' ');
    
end


% Задание среднеквадратического отклонения "шума" измерений:
prompt = 'Задайте среднеквадратическое отклонение "шума" измерений, В:   ';
std_noise = input(prompt);
disp(' ');


% Задание общего времени существования сигнала:
full_time = input('Введите общее время существования сигнала, с:   ');
disp(' ');
%
% ПРИМЕЧАНИЕ. По сути, это общее время сбора аналоговых данных. Не все
% данные (даже уже оцифрованные) будут использованы для расчёта
% синхрофазоров, частоты и скорости изменения частоты, поскольку по
% истечении "full_time" (и даже в сам момент истечения) дискретные отсчёты
% сигнала более не будут забираться из буфера (см. "buf_rate").


% Задание частоты дискретизации сигнала:
prompt = [ 'Задайте частоту дискретизации сигнала, Гц', ...
           '\n(сначала осуществляем дискретизацию сигнала с этой', ...
           '\nвысокой частотой, а затем, если необходимо, - прореживание):   ' ];
samp_rate = input(prompt);
disp(' ');


% Определение необходимости прореживания исходного сигнала:
prompt = [ 'Определите, необходимо ли прореживать исходный', ...
           '\nаналоговый сигнал; задайте 1, если да, и любое другое', ...
           '\nчисло, если нет:   ' ];
decim_need = input(prompt);
disp(' ');
%
if decim_need == 1
    decim_need = true;
else
    decim_need = false;
end


if decim_need   % если требуется прореживание
    
    % Задание параметра прореживания:
    prompt = [ 'Задайте параметр прореживания (целое число, большее 1);', ...
               '\nво столько раз будет прорежен исходный сигнал', ...
               '\n(после применения ФНЧ для избежания "aliasing"):   ' ];
    dec_factor = input(prompt);
    disp(' ');
    
end


% Задание интервала времени между метками времени, для которых мы хотим
% получать выходные данные (т.е., по сути, периода передачи синхрофазоров
% на верхний уровень иерархии):
prompt = [ 'Задайте период передачи рассчитанных значений синхрофазоров,' ...
           '\nчастоты и "df/dt" на верхний уровень иерархии, с:   ' ];
dt_GPS = input(prompt);
disp(' ');


% Задание момента времени, соответствующего первой метке времени, для
% которой получим выходные данные:
prompt = [ 'Задайте момент времени, соответствующий первой метке времени,' ...
           '\nдля которой хотим иметь выходные данные, с', ...
           '\n(лучше, чтобы эта метка не совпадала с метками,', ...
           '\nсоответствующими дискретным отсчётам сигнала,', ...
           '\nдля имитации реальной ситуации):   ' ];
time_stamp_1 = input(prompt);
disp(' ');


% Задание размера буфера, содержащего дискретные отсчеты аналогового
% сигнала (имитация подобного буфера в реальном УСВИ):
prompt = [ 'Задайте размер циклического буфера (количество выборок),' ...
           '\nсодержащего дискретные отсчёты входного аналогового сигнала' ...
           '\n(ещё не прореженного):   ' ];
buf_size = input(prompt);
disp(' ');
%
% ПРИМЕЧАНИЕ. Непосредственно заполнение самого буфера мгновенных значений
% имитировать не будем; просто будем имитировать опросы этого буфера через
% интервалы времени "buf_dt" (см. цикл "while" ниже в разделе
% "V. Реализация "ядра" алгоритма.").


% Задание частоты опроса буфера:
buf_rate = input('Задайте частоту опроса буфера, Гц:   ');
disp(' ');


% Выбор алгоритма отслеживания частоты:
prompt = [ 'Выберите алгоритм отслеживания частоты сигнала:', ...
           '\n1 - линейный МНК;', ...
           '\n2 - модификация алгоритма, изложенного в стандарте C37.118:   ' ];
freq_alg = input(prompt);
disp(' ');



%%
% -------------------------------------------------------------------------
% II. Создание модели сигнала.
% -------------------------------------------------------------------------



switch which_signal
    
    % Каждый сигнал представляет собой вектор-строку:
    
    case 1
        
        % "Чистая" (без гармоник) синусоида:
        sig_model = @(t, noise) ...
        (  A*cos(2*pi*freq*t+fi) + noise*randn(1, numel(t))  );
    
    case 2
        
        % Синусоида с третьей гармоникой:
        sig_model = @(t, noise) ...
        (  A*cos(2*pi*freq*t+fi) + A3*cos(2*pi*3*freq*t+fi) + noise*randn(1, numel(t))  );
    
    case 3
        
        % Сигнал с увеличивающейся частотой
        % (частота соответствует "freq" в начальный момент времени t = 0):
        sig_model = @(t, noise) ...
        (  A*cos(2*pi*freq*t+pi*df_dt*t.^2+fi) + noise*randn(1, numel(t))  );
    
    otherwise
        
        error('   !!! Задана неверная модель сигнала !!!   ');
        
end



%%
% -------------------------------------------------------------------------
% III. Вычисление "истинных" значений синхрофазоров, частоты и "df/dt".
% -------------------------------------------------------------------------



% Определим "истинные" значения всех требуемых выходных параметров -
% синхрофазоров, частоты и скорости изменения частоты, соответствующие всем
% меткам времени для прореженного сигнала (при отсутствии прореживания -
% для исходного сигнала), а также всем меткам времени, для которых мы хотим
% получать выходные данные и передавать их на верхний уровень.
%
% Таким образом, определение искомых параметров (синхрофазоров, частоты и
% скорости изменения частоты) и расчёт соответствующих погрешностей будем
% осуществлять не только для моментов времени, требуемых для агрегации
% данных на верхнем уровне иерархии (см. "t_GPS = time_stamp_1 : dt_GPS :
% full_time;"), но и для моментов времени, для которых эти параметры
% могут вычисляться "внутри" УСВИ (см. "t_all_raw = 0 : dt : full_time;"
% и "t_all = (dt_decim - dt) : dt_decim : full_time;").
%
% ПРИМЕЧАНИЕ. Как описано в разделе "V. Реализация "ядра" алгоритма.", мы
% используем "Chebyshev IIR filter" с целью прореживания сигнала и
% гарантируем то, что первая прореженная выборка нового окна данных отстоит
% по времени от последней прореженной выборки старого окна данных на один и
% тот же интервал времени - "dt_decim". При таком раскладе мы должны
% получить следующий массив меток времени для прореженного сигнала:
% "t_all = (dt_decim - dt) : dt_decim : full_time;".


% Массивы меток времени, соответствующих исходному сигналу и прореженному
% сигналу (если требуется прореживание):

dt = 1 / samp_rate;   % шаг по времени между выборками исходного сигнала
% t_all_raw = 0 : dt : full_time;   % метки времени всех исходных выборок
%
% В связи с небольшой модификацией того, как мы имитируем механизм опроса
% буфера мгновенных значений сигнала, переменная "t_all_raw" более не
% требуется.

if decim_need   % если требуется прореживание
    dt_decim = dt * dec_factor;
    t_all = (dt_decim - dt) : dt_decim : full_time;
else
    dt_decim = dt;   % чтобы не выполнять эту проверку каждый раз там, где
                     % требуется задать "dt"
    % t_all = t_all_raw;
    t_all = 0 : dt : full_time;
end


% Массив меток времени, для которых мы хотим получать выходные данные,
% передаваемые на верхний уровень иерархии:
t_GPS = time_stamp_1 : dt_GPS : full_time;


% ПРИМЕЧАНИЕ. Полученные массивы меток времени "t_all" и "t_GPS" нам
% требуются для вычисления "истинных" значений синхрофазоров, частоты и
% "df/dt" (см. ниже), а также для анализа результатов (например, для
% построения графиков). Обращаться к этим массивам для выделения меток
% времени непосредственно в главном цикле не требуется, т.к. мы знаем
% начало каждого массива ("dt_decim - dt" и "time_stamp_1"
% соответственно) и шаг ("dt_decim" и "dt_GPS" соответственно).


% "Истинные" значения синхрофазоров, частоты и "df/dt":

if which_signal == 3
    
    % Сигнал с увеличивающейся частотой
    % (частота соответствует "freq" в начальный момент времени t = 0;
    % фазовый угол соответствует "fi" в начальный момент времени t = 0):
    %
    ang_true_all = angle(  exp(1i*fi) * exp(1i*(freq-50)*2*pi*t_all) .* ...
    exp(1i*pi*df_dt*t_all.^2)  );   % в радианах
    ang_true_GPS = angle(  exp(1i*fi) * exp(1i*(freq-50)*2*pi*t_GPS) .* ...
    exp(1i*pi*df_dt*t_GPS.^2)  );   % в радианах
    %
    % ПРИМЕЧАНИЕ. Из стандарта IEEE C37.118.1-2011: "synchrophasors are
    % commonly reported in angles –180 degrees to +180 degrees rather than
    % 0 to 360 degrees", так что всё должно быть верно.
    %
    Ph_true_all = (A/sqrt(2)) * exp(1i*ang_true_all);
    Ph_true_GPS = (A/sqrt(2)) * exp(1i*ang_true_GPS);
    %
    f_true_all = freq + df_dt * t_all;
    f_true_GPS = freq + df_dt * t_GPS;
    %
    deriv_true = df_dt;
    
else
    
    % "Чистая" (без гармоник) синусоида или же синусоида с третьей
    % гармоникой:
    %
    Ph_true_all = (A/sqrt(2)) * exp(1i*fi) * exp(1i*(freq-50)*2*pi*t_all);
    Ph_true_GPS = (A/sqrt(2)) * exp(1i*fi) * exp(1i*(freq-50)*2*pi*t_GPS);
    %
    f_true_all = freq * ones(1, numel(t_all));
    f_true_GPS = freq * ones(1, numel(t_all));
    %
    deriv_true = 0;
    
end



%%
% -------------------------------------------------------------------------
% IV. Инициализация некоторых необходимых массивов.
% -------------------------------------------------------------------------



% Инициализируем часть необходимых переменных, имитирующих буферы
% мгновенных значений сигнала и синхрофазоров, а также сохраняющих все
% рассчитанные значения синхрофазоров, частоты и "df/dt", соответствующие
% заданным меткам времени.


% Буфер прореженных мгновенных значений сигнала, необходимый для вычисления
% синхрофазоров и содержащий часть отсчётов окна данных, другая часть
% которого будет известна только в "будущем":
%
if decim_need   % если требуется прореживание
    %
    % Количество дискретных отсчётов на период гармоники 50 Гц:
    to_round = (  (samp_rate/50) / dec_factor  ) / 2;
    N = 2 * round(to_round);   % "N" - только чётное число
    %
else
    %
    % Количество дискретных отсчётов на период гармоники 50 Гц:
    to_round = (  samp_rate/50  ) / 2;
    N = 2 * round(to_round);   % "N" - только чётное число
    %
end
%
buf_samp_part = zeros(2, 2*N);
%
% ПРИМЕЧАНИЕ 1. Первая строка - непосредственно мгновенные значения; вторая
% строка - соответствующие метки времени.
% ПРИМЕЧАНИЕ 2. Берём "2*N" с запасом, а на самом деле, очевидно,
% достаточно иметь "N-1" выборок (для одного из синхрофазоров не будет
% хватать лишь одной выборки).
% ПРИМЕЧАНИЕ 3. Будем реализовывать только однопериодное ДПФ.
%
disp(' ');
disp( ['Число выборок на период: ', num2str(N), '.'] );
disp(' ');


% Буфер синхрофазоров, необходимый для вычисления частоты и "df/dt":
buf_ph = zeros(2, 5*N);
%
% ПРИМЕЧАНИЕ 1. Первая строка - непосредственно синхрофазоры; вторая строка
% - соответствующие метки времени.
% ПРИМЕЧАНИЕ 2. Вне зависимости от заданного алгоритма отслеживания частоты
% (входной параметр "freq_alg") сохраняем как минимум пять окон данных
% ("5*N"), содержащих рассчитанные синхрофазоры (с некоторым запасом).
% Например, чтобы корректно вычислить частоту, соответствующую некоторому
% значению синхрофазора (его метке времени) при использовании алгоритма
% отслеживания частоты на основе линейного МНК, необходимо знать примерно
% "(2*N + round(N/6))*2" значений синхрофазоров "назад" и столько же
% "вперёд".
% ПРИМЕЧАНИЕ 3. А почему, собственно, "(2*N + round(N/6))*2", а не "(2*N +
% round(N/6))"? Дело в том, что - в зависимости от частоты опроса буфера
% ("buf_rate") - может получиться так, что к старым "(2*N + round(N/6))"
% синхрофазорам добавятся меньше "(2*N + round(N/6))" новых синхрофазоров
% (в пределе - вообще 1 новый синхрофазор). Поэтому, обновляя буфер
% синхрофазоров "buf_ph" новыми данными, будем терять старые и не сможем
% оценить частоту и "df/dt" вообще ни на какой стадии процесса.


% Инициализация переменных, содержащих все рассчитанные значения
% синхрофазоров, частоты и "df/dt":
%
num_all = numel(t_all);   % общее количество меток времени "t_all"
Ph_c_all = zeros(1, num_all);
f_c_all = zeros(1, num_all);
deriv_c_all = zeros(1, num_all);
%
num_GPS = numel(t_GPS);   % общее количество меток времени "t_GPS"
Ph_c_GPS = zeros(1, num_GPS);
f_c_GPS = zeros(1, num_GPS);
deriv_c_GPS = zeros(1, num_GPS);
%
% ПРИМЕЧАНИЕ. Количество рассчитанных значений синхрофазоров, частоты и
% "df/dt", на самом деле, будет меньше по сравнению с соответствующими
% параметрами "num_all" и "num_GPS" (т.е. часть элементов в объявленных
% массивах так и останется "нулями", а часть значений будет
% недокорректирована из-за отсутствия части окна данных в "прошлом" или в
% "будущем").
% Помимо ограниченного времени существования сигнала (определяющего все
% "концевые эффекты" в начале и в конце процесса), часть исходных
% оцифрованных мгновенных значений сигнала просто не будет обработана
% алгоритмом расчёта синхрофазоров (это значения сигнала, собранные за
% время между последним опросом буфера мгновенных значений и окончанием
% процесса сбора данных в момент времени "full_time").


% Убедимся, что массивы "t_all" и "t_GPS" содержат минимально необходимое
% количество элементов (иначе все вычисления лишены здравого смысла):
if (  (numel(t_all) < N) || (numel(t_GPS) < 1)  )
    error('   !!! Недостаточное количество синхрофазоров !!!   ');
end


% Инициализация переменных, содержащих все рассчитанные погрешности
% вычисления синхрофазоров, частоты и скорости изменения частоты:
%
TVE_all = zeros(1, num_all);   % полная векторная погрешность ("TVE") в процентах
df_all = zeros(1, num_all);   % отклонение частоты от "истинной", Гц
df_dt_all = zeros(1, num_all);   % отклонение скорости изменения частоты от "истинной", Гц/с
%
TVE_GPS = zeros(1, num_GPS);
df_GPS = zeros(1, num_GPS);
df_dt_GPS = zeros(1, num_GPS);


% Будем также рассчитывать алгоритмические задержки для каждого
% вычисленного синхрофазора:
delay_all = zeros(1, num_all);
delay_GPS = zeros(1, num_GPS);
%
% ПРИМЕЧАНИЕ. Каждая задержка будет именно АЛГОРИТМИЧЕСКОЙ, т.е.
% представляет собой разность между моментом времени, соответствующем
% моменту времени опроса буфера мгновенных значений, в котором присутствует
% последнее необходимое дискретное значение сигнала, и моментом,
% соответствующем метке времени синхрофазора. Очевидно, эта разность тем
% меньше, чем чаще мы опрашиваем буфер.
% Помимо алгоритмической, в реальности будут другие аппаратные задержки,
% связанные с вычислением каждого конкретного синхрофазора, отслеживанием
% фактической частоты и т.д.



%%
% -------------------------------------------------------------------------
% V. Реализация "ядра" алгоритма.
% -------------------------------------------------------------------------



% Интервал опроса буфера мгновенных значений сигнала, с:
buf_dt = 1 / buf_rate;
if buf_dt >= full_time
    error('   !!! Буфер мгновенных значений не может быть опрошен !!!   ');
elseif buf_dt <= (dt * 2)   % с запасом
    error('   !!! Слишком частый опрос буфера мгновенных значений !!!   ');
end


% Проверяем, достаточен ли размер буфера мгновенных значений (а он задаётся
% пользователем) для хранения всех оцифрованных мгновенных значений
% сигнала, собранных за один период опроса буфера:
if numel(0 : dt : buf_dt) >= buf_size   % т.е. буфер должен быть строго
                                        % больше (для некоторого запаса)
    error('   !!! Размер буфера мгновенных значений слишком мал !!!   ');
end
%
% ПРИМЕЧАНИЕ. Непосредственно заполнение самого буфера мгновенных значений
% имитировать не будем; просто будем имитировать опросы этого буфера через
% интервалы времени "buf_dt" (см. цикл "while" ниже).


% Общее количество опросов буфера мгновенных значений сигнала:
total_buf_requests = floor(full_time / buf_dt);


% Вектор, где каждый элемент представляет собой количество выборок, взятых
% из буфера при каждом опросе (интересно посмотреть). По-моему, при
% нормальном ходе процесса и отсутствии прореживания элементы этого вектора
% не должны отличаться больше чем на 1; при прореживании они не должны
% отличаться больше чем на "dec_factor" (но это с учётом возможного
% присоединения части выборок прошлого опроса - см. "old_samp" ниже):
each_buf_request = zeros(1, total_buf_requests);


% Вспомогательная переменная, необходимая для заполнения вектора
% "each_buf_request":
buf_request_number = 0;


% Вспомогательная логическая переменная, необходимая для определения того,
% можно ли взять из буфера мгновенных значений последние "N-1" выборок для
% вычисления очередной порции синхрофазоров:
flag_samp_attach = true;   % если "true", то нужно проверять, можно ли это
                           % сделать (см. цикл "while" ниже)


% Вспомогательная переменная, значение которой соответствует количеству
% синхрофазоров, рассчитанных и, если возможно (если имелось достаточное
% для отслеживания частоты количество синхрофазоров "слева" и "справа"),
% откорректированных, т.е. полностью готовых к передаче на верхний уровень
% иерархии:
num_ready_all = N/2 - 1;   % первые "N/2 - 1" синхрофазоров рассчитать всё
                           % равно не сможем
%
% ПРИМЕЧАНИЕ 1. Эта переменная будет отвечать за заполнение массивов
% "Ph_c_all", "f_c_all" и "deriv_c_all". При реализации ДПФ мы используем
% окно с чётным количеством выборок "N", а фаза синхрофазора рассчитывается
% на центр этого окна, т.е. метка времени для каждого синхрофазора будет
% посередине между метками времени ближайших мгновенных значений "слева" и
% "справа" от центра окна ДПФ. Поэтому для соответствия меткам времени
% "t_all" необходимо повернуть каждый синхрофазор "назад" (умножить на
% "exp(j*(freq_est-50)*2*pi*(-dt/2))" или на
% "exp(j*(freq_est-50)*2*pi*(-dt_decim/2))", где "freq_est" - вычисленная
% фактическая частота, соответствующая метке времени синхрофазора; если
% частоту пока не отследили, значит, поворачиваем на "exp(j*0)", т.е.
% вообще не поворачиваем).
% ПРИМЕЧАНИЕ 2. В начале процесса, пока не накоплено достаточное для
% отслеживания частоты количество синхрофазоров, синхрофазоры считаются
% готовыми по факту их расчёта с помощью ДПФ; далее же ожидаем коррекции
% синхрофазоров по факту вычисления частоты, соответствующей их меткам
% времени, и только тогда они становятся готовыми.
%
% Считаем, что полная векторная погрешность для первых "N/2 - 1"
% синхрофазоров равна 100 процентов:
TVE_all(1:(N/2-1)) = 100;


% Вспомогательная переменная, значение которой соответствует количеству
% синхрофазоров, рассчитанных с помощью функции "Phasor_computation" (см.
% цикл "while" ниже):
num_phasors_computed = 0;


% Определяем метки времени из массива "t_GPS", для которых точно не сможем
% рассчитать синхрофазоры (в начале процесса, пока не получим первый
% синхрофазор):
%
% Метка времени первого синхрофазора:
t_begin = t_all(1) + (N-1)*dt_decim/2;
%
% Количество предшествующих по отношению к "t_begin" меток времени из
% массива "t_GPS", разница во времени с которыми превышает половину шага
% (т.е. "dt_decim/2"), что делает невозможным корректировку с помощью поворота синхрофазоров "назад":
GPS_ignored = numel(   find( (t_begin - t_GPS) > dt_decim/2 )   );
%
% Вспомогательная переменная, отвечающая за следующую метку времени из
% массива "t_GPS", для которой требуется вычислить (но пока это не сделано)
% синхрофазор, частоту и "df/dt":
next_t_GPS = time_stamp_1 + GPS_ignored*dt_GPS;   % учитываем, что для первых "GPS_ignored" меток
                                                  % (включая "time_stamp_1")
                                                  % ничего вычислить не
                                                  % сможем
%
% Вспомогательная переменная, значение которой соответствует количеству
% синхрофазоров, рассчитанных, откорректированных (если возможно) и
% использованных для передачи на верхний уровень в соответствии с метками
% времени "t_GPS":
num_ready_GPS = GPS_ignored;   % первые "GPS_ignored" синхрофазоров, передаваемые
                               % на верхний уровень иерархии,
                               % так и останутся "нулями"
%
% Считаем, что полная векторная погрешность для первых "GPS_ignored"
% синхрофазоров равна 100 процентов:
TVE_GPS(1:GPS_ignored) = 100;

                               
% Вспомогательная переменная, определяющая "N"-ю метку времени прореженного
% сигнала (или исходного, если прореживание не требуется):
time_stamp_Nth = t_all(1) + (N-1)*dt_decim;   % можем вычислять синхрофазоры, начиная
                                              % с получения выборки с этой меткой времени
                                                                                            

% Вспомогательная переменная, значение которой соответствует количеству
% синхрофазоров в "прошлом", необходимых для корректного расчёта частоты и
% "df/dt" (пока не накопим это количество синхрофазоров, рассчитать частоту
% и на этой основе откорректировать синхрофазоры не получится):
switch freq_alg
    case 1
        phasors_for_freq_track = 2*N + ceil(N/6) + 1;   % с запасом
    case 2
        phasors_for_freq_track = ceil( ((N/2-1)-1)/2 ) + ceil(N/6) + 1;   % с запасом
    otherwise
        error('   !!! Неизвестный алгоритм отслеживания частоты !!!   ');
end


% Вспомогательная логическая переменная, необходимая для определения того,
% можно ли взять из буфера синхрофазоров последние "phasors_for_freq_track"
% значений (если да, все вновь рассчитанные синхрофазоры имеют шанс быть
% откорректированы с помощью оценки реальной частоты, поскольку для каждого
% из них имеется необходимая история в "прошлом" и остаётся дождаться
% только необходимой части окна в "будущем"):
flag_ph_attach = true;   % если "true", то нужно проверять, можно ли это
                         % сделать (см. цикл "while" ниже)


% Вспомогательные переменные, используемые при расчёте синхрофазоров с
% помощью ДПФ:
aux_1 = sqrt(2) / N;
aux_2 = exp( -1i * 2 * pi * (-(N-1)/2 : (N-1)/2) / N );


% Вспомогательная переменная - номинальная угловая частота (рад/с):
omega_n = 2*pi*50;


% Будем строить графики и обновлять их примерно 10 раз во время
% функционирования алгоритма (или реже - в зависимости от соотношения
% "full_time / 10" и "buf_dt"):
time_plot = max( [full_time / 10, buf_dt] );
time_plot_dt = time_plot;   % шаг обновления


% Необходимый графический объект:
handle = figure;
set(gcf, 'Position', get(0, 'Screensize'));


% Инициализация переменной, имитирующей текущий момент времени:
time = 0;


% Инициализация переменной, представляющей собой метку времени,
% соответствующую первой выборке при очередном опросе буфера мгновенных
% значений:
t_first_new = 0;


% Обновление генератора случайных чисел:
rng('shuffle');   % для генерации "шума" измерений


if decim_need   % если требуется прореживание


%     % --- ТОЛЬКО ДЛЯ ТЕСТИРОВАНИЯ: ---
%     ALL_SAMPLES = [0; 0];
%     ALL_SAMPLES_DEC = [0; 0];
%     ALL_PHASORS = [0; 0];
%     % ---
    
    
    % Проверяем, а будет ли вообще достаточное количество выборок для
    % прореживания в очередной порции сигнала, взятой из буфера:
    if numel(0 : dt : buf_dt) <= (dec_factor * 2)   % с запасом
        error('   !!! Слишком частый опрос буфера мгновенных значений !!!   ');
    end
    
    % Вспомогательная переменная, необходимая для присоединения части
    % мгновенных значений сигнала, взятых из буфера, к началу массива
    % мгновенных значений, который будет взят из буфера при следующем его
    % опросе:
    old_samp = 0;   % переменная будет содержать количество присоединяемых
                    % значений
    %
    % ПРИМЕЧАНИЕ. Дело в том, что для упрощения контроля над прореживанием
    % сигнала необходимо, чтобы метка времени последнего мгновенного
    % значения текущей порции прореженного сигнала совпадала с
    % последней меткой времени текущей порции исходного сигнала, но при
    % этом метка времени первого мгновенного значения новой порции
    % прореженного сигнала должна отстоять от предыдущей метки времени (в
    % старой порции) на интервал времени "dt_decim". Поэтому остаток
    % мгновенных значений (если таковой имеется) переносим на следующий
    % раз.
    % Для дополнительного разъяснения см. описание функции "decimate"
    % в справке по MATLAB (используемый фильтр - "Chebyshev IIR filter");
    % алгоритм IIR (а не FIR) выбираем потому, что есть подозрения, что он
    % будет несколько лучше функционировать в плане уменьшения влияния
    % "шума" (на основании наших предыдущих подробных исследований
    % алгоритма 4 отслеживания частоты).
    
    % Главный цикл  с прореживанием:

    while (time + buf_dt) < full_time   % когда процесс сбора данных закончится
                                        % или заканчивается ("= full_time"),
                                        % буфер опросить уже не сможем
    
        % Имитируем опросы буфера мгновенных значений сигнала через интервалы
        % времени "buf_dt":
        time_prev = time;   % предыдущая метка времени опроса буфера
        time = time_prev + buf_dt;   % метка времени нового опроса
        
%         % Присоединяем выборки, взятые из прошлого опроса буфера:
%         time_prev = time_prev - old_samp * dt;
%         %
%         % ПРИМЕЧАНИЕ. Выборки из прошлого опроса, количество которых равно
%         % "old_samp", в реальности тоже где-то нужно будет сохранять. Здесь
%         % мы это не делаем, а лишь имитируем сдвиг "назад" по времени на
%         % "old_samp * dt", чтобы забрать и присоединить эти выборки.
%         % ВНИМАНИЕ! Таким образом, нужен небольшой дополнительный буфер для
%         % исходных мгновенных значений сигнала (не путать с буфером
%         % прореженных значений сигнала "buf_samp_part"). Альтернативно
%         % (если вообще возможно): не опустошать буфер мгновенных значений
%         % на устройстве полностью, а оставлять там "old_samp" выборок.
        %
        % Так, как выше (закомментировано), должно быть в идеале. А
        % результаты нашего предварительного "прогона" данного кода
        % показывают, что из-за ошибок округления данный механизм может
        % иногда сбиваться. Поэтому для более чёткой имитации ситуации
        % будем использовать вспомогательную переменную "t_first_new" (см.
        % ниже).
    
        % Мгновенные значения сигнала, накопленные за интервал времени между
        % двумя последовательными опросами буфера мгновенных значений:
        %
        % Выделяем метки времени:
%         t_stamps_raw = ...
%         t_all_raw( (t_all_raw >= time_prev) & (t_all_raw < time) );
%         % (наличие в одном случае строгого знака ("<"), а в другом - нестрогого
%         % (">="), гарантирует то, что все взятые из буфера данные уникальны;
%         % при этом нестрогий знак соответствует более ранней метке времени,
%         % иначе не заберём выборку с самой первой меткой времени (t = 0); кроме
%         % того, строгий знак, соответствующий более поздней метке времени,
%         % имитирует тот факт, что последняя взятая выборка должна появиться в
%         % буфере хотя бы на мгновение раньше момента времени опроса буфера)
        %
        % Так, как выше (закомментировано), должно быть в идеале. А
        % результаты нашего предварительного "прогона" данного кода
        % показывают, что из-за ошибок округления число выборок, взятое из
        % буфера мгновенных значений, может отличаться на 2 (чего не должно
        % быть при наличии в одном случае строгого знака, а в другом -
        % нестрогого (см. выше)), например:
        % [ min(each_buf_request), max(each_buf_request) ]
        % ans =
        %     29    31
        % Поэтому поступаем иначе: фиксируем метку времени ("t_first_new"),
        % которая будет соответствовать первой выборке, взятой при
        % очередном опросе буфера, и начинаем отсчёт с неё с шагом "dt";
        % затем обновляем значение "t_first_new":
        t_stamps_raw = t_first_new : dt : time;
        t_first_new = t_stamps_raw(end) + dt;   % только предварительно
        %
        % Вычисляем количество меток времени и оставляем столько, сколько
        % кратно "dec_factor" (по максимуму), перенося остальное на
        % следующий раз:
        num_samp = floor( numel(t_stamps_raw) / dec_factor ) * dec_factor;
        old_samp = numel(t_stamps_raw) - num_samp;
        t_stamps_raw = t_stamps_raw(1 : (end - old_samp));
        t_first_new = t_first_new - old_samp * dt;   % окончательно
        %
        % Вычисляем значения сигнала, соответствующие этим меткам времени:
        sig = sig_model(t_stamps_raw, std_noise);
        %
        % Сохраняем информацию о количестве мгновенных значений (дискретных
        % отсчётов) сигнала, взятых из буфера:
        buf_request_number = buf_request_number + 1;
        each_buf_request(buf_request_number) = numel(sig);
        
%         % --- ТОЛЬКО ДЛЯ ТЕСТИРОВАНИЯ: ---
%         ALL_SAMPLES = [ ALL_SAMPLES, [sig; t_stamps_raw] ];
%         % ---
    
        % Прореживаем сигнал, используя "Chebyshev IIR filter of order 5":
        sig_dec = decimate(sig, dec_factor, 5);
        
        % Выделяем метки времени для прореженного сигнала:
        t_stamps_dec = downsample(t_stamps_raw, dec_factor, dec_factor-1);
        
        % Формируем матрицу из двух строк, поскольку и заполнение буфера, и
        % поставку сигнала в функцию вычисления синхрофазоров осуществляем
        % в матричном виде:
        new_dec = [ sig_dec; t_stamps_dec ];
        
%         % --- ТОЛЬКО ДЛЯ ТЕСТИРОВАНИЯ: ---
%         ALL_SAMPLES_DEC = [ALL_SAMPLES_DEC, new_dec];
%         % ---
        
        % Проверяем, достаточно ли уже накоплено выборок для вычисления
        % первого синхрофазора, и - если да - производим все необходимые
        % вычисления:
        if t_stamps_dec(end) >= time_stamp_Nth

            % Определяем, сколько же выборок из буфера можем
            % присоединить для вычисления синхрофазоров (в пределе - "N-1",
            % т.к. для вычисления одного из синхрофазоров не хватало лишь
            % одной выборки):
            if flag_samp_attach
                samp_attach = round( (t_stamps_dec(1) - t_all(1)) / dt_decim );
                samp_attach = min( [samp_attach, N-1] );
                if samp_attach >= (N-1)
                    flag_samp_attach = false;   % это означает, что в буфере к этому моменту
                                                % должно быть накоплено достаточное количество
                                                % выборок, поэтому в дальнейшем
                                                % "flag_samp_attach = false"
                end
            else
                samp_attach = N-1;
            end
            
            % Присоединяем необходимое количество выборок из буфера и
            % рассчитываем синхрофазоры:
            samp_for_phasors = [ buf_samp_part(:, (end-samp_attach+1):end), new_dec ];
            new_phasors = Phasor_computation(samp_for_phasors, N, dt_decim, 0, aux_1, aux_2);
            
%             % --- ТОЛЬКО ДЛЯ ТЕСТИРОВАНИЯ: ---
%             ALL_PHASORS = [ALL_PHASORS, new_phasors];
%             % ---
            
            % Определяем количество полученных синхрофазоров:
            num_new_phasors = size(new_phasors, 2);
            
            % Обновляем общее количество рассчитанных синхрофазоров:
            num_phasors_computed_previous = num_phasors_computed;   % понадобится позже (см. ниже)
            num_phasors_computed = num_phasors_computed + num_new_phasors;
            
            % Определяем, достаточно ли уже ненулевых значений (под
            % "достаточно" подразумевается их количество, равное
            % "phasors_for_freq_track") накоплено в буфере синхрофазоров,
            % чтобы откорректировать все вновь поступившие синхрофазоры
            % "new_phasors" по факту вычисления частоты (если, конечно, для
            % каждого из синхрофазоров "new_phasors" будет достаточное
            % количество синхрофазоров ("phasors_for_freq_track") в
            % "будущем", чего мы не знаем наперёд):
            if flag_ph_attach
                
                % Определяем, сколько синхрофазоров не могут быть
                % откорректированы по факту вычисления частоты, и выделяем
                % сами эти синхрофазоры:
                num_phasors_diff = num_phasors_computed - phasors_for_freq_track;
                if num_phasors_diff < 1
                    % Ни один из вновь прибывших синхрофазоров не сумеем
                    % откорректировать, т.е. все они уже готовы:
                    num_phasors_ready = num_new_phasors;
                    phasors_ready = new_phasors;
                else
                    % Не сумеем откорректировать все синхрофазоры, кроме
                    % последних "num_phasors_diff":
                    num_phasors_ready = num_new_phasors - num_phasors_diff;
                    phasors_ready = new_phasors(:, 1:num_phasors_ready);
                end
                
                % Отдельно проверяем, следует ли нам в будущем (на
                % следующей итерации) заходить в эту ветвь условного
                % оператора ("if flag_ph_attach"):
                if num_phasors_diff >= 0
                    flag_ph_attach = false;
                end
                
                % Используем рассчитанные синхрофазоры для определения
                % значений синхрофазоров, соответствующих меткам времени
                % "t_GPS", а также погрешностей "TVE_GPS" и алгоритмических
                % задержек "delay_GPS":
                for k = 1 : num_phasors_ready
                    
                    % Разность между меткой времени очередного синхрофазора
                    % и следующей меткой времени из массива "t_GPS":
                    each_time_diff = phasors_ready(2, k) - next_t_GPS;
                    
                    if abs(each_time_diff) <= (dt_decim/2 + 1e-6)
                        %
                        % ПРИМЕЧАНИЕ. Небольшая добавка в 1 мкс ("1e-6")
                        % здесь и далее в нескольких местах необходима для
                        % того, чтобы с гарантией "подцеплять" все метки
                        % времени "t_GPS". Предварительные эксперименты
                        % показали, что из-за ошибок округления может
                        % получиться так, что очередную метку времени из
                        % массива "t_GPS" не считают "своей" ни синхрофазор
                        % с меткой времени примерно на "dt_decim/2" раньше,
                        % ни синхрофазор с меткой времени примерно на
                        % "dt_decim/2" позже (несмотря на знак нестрогого
                        % неравенства "<=").
                        
                        % Индекс текущей метки времени из массива "t_GPS":
                        num_ready_GPS = num_ready_GPS + 1;
                                                
                        % Синхрофазор, соответствующий метке времени
                        % "t_GPS":
                        Ph_c_GPS(num_ready_GPS) = phasors_ready(1, k) * ...
                        exp(-1i*0*each_time_diff);
                        %
                        % ПРИМЕЧАНИЕ. Реальная частота сигнала пока не
                        % известна, поэтому синхрофазор не можем повернуть,
                        % т.е. просто берём ближайший.
                    
                        % Погрешность вычисления синхрофазора:
                        [TVE_calc, ~, ~] = ...
                        Error_computation(Ph_true_GPS(num_ready_GPS), Ph_c_GPS(num_ready_GPS), ...
                        0, 0, 0, 0);
                        TVE_GPS(num_ready_GPS) = TVE_calc;
                        
                        % Алгоритмическая задержка:
                        delay_GPS(num_ready_GPS) = time - next_t_GPS;
                        
                        % Следующая метка времени из массива "t_GPS", за
                        % которой необходимо следить:
                        next_t_GPS = next_t_GPS + dt_GPS;
                    
                    end
                    %
                    % ПРИМЕЧАНИЕ. Поскольку частота и скорость изменения
                    % частоты для этой группы синхрофазоров
                    % "num_phasors_ready" не оценивались, соответствующие
                    % элементы векторов "f_c_GPS" и "deriv_c_GPS" пока
                    % остаются нулями. То же относится и к элементам
                    % векторов "df_GPS" и "df_dt_GPS".
                    
                end
                
                % Используем рассчитанные синхрофазоры для определения
                % значений синхрофазоров, соответствующих меткам времени
                % "t_all", а также погрешностей "TVE_all" и алгоритмических
                % задержек "delay_all":
                %
                % Индексы меток времени из массива "t_all":
                t_stamps_ind = num_ready_all + (1:num_phasors_ready);
                %
                % Синхрофазоры, соответствующие меткам времени "t_all":
                Ph_c_all(t_stamps_ind) = phasors_ready(1, :) * ...
                exp(-1i*0*dt_decim/2);
                %
                % ПРИМЕЧАНИЕ. Реальная частота сигнала пока не
                % известна, поэтому синхрофазор не можем повернуть,
                % т.е. просто берём ближайший.
                %
                % Погрешности вычисления синхрофазоров:
                [TVE_calc, ~, ~] = ...
                Error_computation(Ph_true_all(t_stamps_ind), Ph_c_all(t_stamps_ind), ...
                0, 0, 0, 0);
                TVE_all(t_stamps_ind) = TVE_calc;
                %
                % Алгоритмические задержки:
                delay_all(t_stamps_ind) = time - t_all(t_stamps_ind);
                
                % Обновляем информацию об общем количестве синхрофазоров,
                % готовых к передаче на верхний уровень иерархии:
                num_ready_all = num_ready_all + num_phasors_ready;
                
            end
            
            % Определяем, достаточно ли уже накоплено синхрофазоров для
            % оценки частоты (и коррекции синхрофазоров на этой основе), а
            % также "df/dt":
            if num_phasors_computed > (2*phasors_for_freq_track)
                
                % Смотрим, сколько рассчитанных синхрофазоров было
                % накоплено в буфере, и присоединяем максимум
                % "2*phasors_for_freq_track" синхрофазоров из буфера (общее
                % количество синхрофазоров, определяющих одно окно для
                % расчёта частоты и "df/dt", равно
                % "2*phasors_for_freq_track+1", т.е. для коррекции одного
                % из синхрофазоров не хватало всего лишь одного нового
                % значения):
                ph_attach = min( [num_phasors_computed_previous, 2*phasors_for_freq_track] );
                
                % Присоединяем необходимое количество синхрофазоров из
                % буфера, рассчитываем частоту и "df/dt", а также
                % корректируем синхрофазоры на основе информации о
                % фактической частоте:
                phasors_for_freq = [ buf_ph(:, (end-ph_attach+1):end), new_phasors ];
                [phasors_ready, f_calc, df_dt_calc] = ...
                Freq_estimation(phasors_for_freq, N, dt_decim, freq_alg, phasors_for_freq_track);
            
                % Определяем количество рассчитанных значений частоты
                % (совпадающее с количеством рассчитанных значений "df/dt",
                % а также с числом откорректированных синхрофазоров):
                num_phasors_ready = numel(f_calc);
            
                % Определяем значения синхрофазоров, частоты и скорости
                % изменения частоты, соответствующие меткам времени
                % "t_GPS", а также рассчитываем соответствующие погрешности
                % и алгоритмические задержки:
                for k = 1 : num_phasors_ready
                    
                    % Разность между меткой времени очередного синхрофазора
                    % и следующей меткой времени из массива "t_GPS":
                    each_time_diff = phasors_ready(2, k) - next_t_GPS;
                    
                    if abs(each_time_diff) <= (dt_decim/2 + 1e-6)
                        
                        % Индекс текущей метки времени из массива "t_GPS":
                        num_ready_GPS = num_ready_GPS + 1;
                                                
                        % Синхрофазор, соответствующий метке времени
                        % "t_GPS":
                        Ph_c_GPS(num_ready_GPS) = phasors_ready(1, k) * ...
                        exp(-1i*(2*pi*f_calc(k)-omega_n)*each_time_diff);
                    
                        % Значения частоты и скорости изменения частоты,
                        % соответствующие этой же метке времени:
                        f_c_GPS(num_ready_GPS) = f_calc(k);
                        deriv_c_GPS(num_ready_GPS) = df_dt_calc(k);
                        %
                        % ПРИМЕЧАНИЕ. Не используем никакую интерполяцию
                        % для значений частоты и скорости изменения
                        % частоты, а просто берём ближайшие рассчитанные
                        % значения (изменение частоты за интервал времени
                        % "dt_decim/2" должно быть очень мало).
                    
                        % Погрешности:
                        [TVE_calc, freq_err_calc, df_dt_err_calc] = ...
                        Error_computation(Ph_true_GPS(num_ready_GPS), Ph_c_GPS(num_ready_GPS), ...
                        f_true_GPS(num_ready_GPS), f_c_GPS(num_ready_GPS), deriv_true, deriv_c_GPS(num_ready_GPS));
                        TVE_GPS(num_ready_GPS) = TVE_calc;
                        df_GPS(num_ready_GPS) = freq_err_calc;
                        df_dt_GPS(num_ready_GPS) = df_dt_err_calc;
                        
                        % Алгоритмическая задержка:
                        delay_GPS(num_ready_GPS) = time - next_t_GPS;
                        
                        % Следующая метка времени из массива "t_GPS", за
                        % которой необходимо следить:
                        next_t_GPS = next_t_GPS + dt_GPS;
                    
                    end
                    
                end
                
                % Определяем значения синхрофазоров, частоты и скорости
                % изменения частоты, соответствующие меткам времени
                % "t_all", а также рассчитываем соответствующие погрешности
                % и алгоритмические задержки:
                %
                % Индексы меток времени из массива "t_all":
                t_stamps_ind = num_ready_all + (1:num_phasors_ready);
                %
                % Синхрофазоры, соответствующие меткам времени "t_all":
                Ph_c_all(t_stamps_ind) = phasors_ready(1, :) .* ...
                exp(-1i*(2*pi*f_calc-omega_n)*dt_decim/2);
                %
                % Значения частоты и скорости изменения частоты,
                % соответствующие этим же меткам времени:
                f_c_all(t_stamps_ind) = f_calc;
                deriv_c_all(t_stamps_ind) = df_dt_calc;
                %
                % Погрешности:
                [TVE_calc, freq_err_calc, df_dt_err_calc] = ...
                Error_computation(Ph_true_all(t_stamps_ind), Ph_c_all(t_stamps_ind), ...
                f_true_all(t_stamps_ind), f_c_all(t_stamps_ind), deriv_true, deriv_c_all(t_stamps_ind));
                TVE_all(t_stamps_ind) = TVE_calc;
                df_all(t_stamps_ind) = freq_err_calc;
                df_dt_all(t_stamps_ind) = df_dt_err_calc;
                %
                % Алгоритмические задержки:
                delay_all(t_stamps_ind) = time - t_all(t_stamps_ind);
                
                % Обновляем информацию об общем количестве синхрофазоров,
                % готовых к передаче на верхний уровень иерархии:
                num_ready_all = num_ready_all + num_phasors_ready;
                
            end
            %
            % ПРИМЕЧАНИЕ. Здесь тоже можно было бы ввести вспомогательную
            % логическую переменную, изменяющую своё значение, когда в
            % буфере появляется как минимум "2*phasors_for_freq_track"
            % синхрофазоров, чтобы не оценивать на каждой последующей
            % итерации, сколько же синхрофазоров необходимо присоединить из
            % буфера. Однако этого делать не будем, т.к. и так много
            % различных переменных.
            
            % Обновляем буфер синхрофазоров:
            buf_ph = Buffer_of_phasors(buf_ph, new_phasors, 5*N);
            
        end
        
        % Обновляем буфер прореженных мгновенных значений сигнала:
        buf_samp_part = Buffer_of_samples(buf_samp_part, new_dec, 2*N);
        
        % Строим графики действующих значений и фазовых углов
        % синхрофазоров, частоты и скорости изменения частоты, а также
        % погрешностей "TVE":
        if (  (time >= time_plot) || ((time + buf_dt) >= full_time)  )
            
            % Будем отображать на всех графиках не более чем "5*N"
            % последних точек данных:
            plot_all = min( [5*N, num_ready_all] );
            plot_GPS = min( [10, num_ready_GPS] );
            
            % Определяем индексы меток времени и сами метки времени:
            plot_all = (num_ready_all-plot_all+1):num_ready_all;
            t_plot_all = t_all(plot_all);
            plot_GPS = (num_ready_GPS-plot_GPS+1):num_ready_GPS;
            t_plot_GPS = t_GPS(plot_GPS);
            
            % Строим графики:
            %
            figure(handle);
            %
            % 1.
            %
            subplot(5,2,1);
            plot(  t_plot_all, abs(Ph_true_all(plot_all)), '.-r', ...
            t_plot_all, abs(Ph_c_all(plot_all)), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('Действ. знач., В');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            title('"Внутренние" вычисления:');
            %
            % 2.
            %
            subplot(5,2,2);
            plot(  t_plot_GPS, abs(Ph_true_GPS(plot_GPS)), '.-r', ...
            t_plot_GPS, abs(Ph_c_GPS(plot_GPS)), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('Действ. знач., В');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            title('"Внешние" вычисления ("привязанные" к GPS):');
            %
            % 3.
            %
            subplot(5,2,3);
            plot(  t_plot_all, angle(Ph_true_all(plot_all))*180/pi, '.-r', ...
            t_plot_all, angle(Ph_c_all(plot_all))*180/pi, '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('Фаза, град.');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            %
            % 4.
            %
            subplot(5,2,4);
            plot(  t_plot_GPS, angle(Ph_true_GPS(plot_GPS))*180/pi, '.-r', ...
            t_plot_GPS, angle(Ph_c_GPS(plot_GPS))*180/pi, '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('Фаза, град.');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            %
            % 5.
            %
            subplot(5,2,5);
            plot(  t_plot_all, f_true_all(plot_all), '.-r', ...
            t_plot_all, f_c_all(plot_all), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('Частота, Гц');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            %
            % 6.
            %
            subplot(5,2,6);
            plot(  t_plot_GPS, f_true_GPS(plot_GPS), '.-r', ...
            t_plot_GPS, f_c_GPS(plot_GPS), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('Частота, Гц');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            %
            % 7.
            %
            subplot(5,2,7);
            plot(  t_plot_all, deriv_true * ones(1, numel(plot_all)), '.-r', ...
            t_plot_all, deriv_c_all(plot_all), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('"df/dt", Гц/с');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            %
            % 8.
            %
            subplot(5,2,8);
            plot(  t_plot_GPS, deriv_true * ones(1, numel(plot_GPS)), '.-r', ...
            t_plot_GPS, deriv_c_GPS(plot_GPS), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('"df/dt", Гц/с');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            %
            % 9.
            %
            subplot(5,2,9);
            plot(  t_plot_all, ones(1, numel(plot_all)), '.-r', ...
            t_plot_all, TVE_all(plot_all), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('"TVE", %');
            legend('"TVE" = 1 %', 'Расчёт',   'Location', 'Best');
            %
            % 10.
            %
            subplot(5,2,10);
            plot(  t_plot_GPS, ones(1, numel(plot_GPS)), '.-r', ...
            t_plot_GPS, TVE_GPS(plot_GPS), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('"TVE", %');
            legend('"TVE" = 1 %', 'Расчёт',   'Location', 'Best');
            
            % Определяем момент времени, по истечении которого будем
            % обновлять все графики:
            time_plot = time_plot + time_plot_dt;
            
            % Небольшая пауза, чтобы рассмотреть графики:
            pause(3);
            
        end
    
    end


else   % если не требуется прореживание
    
    
%     % --- ТОЛЬКО ДЛЯ ТЕСТИРОВАНИЯ: ---
%     ALL_SAMPLES = [0; 0];
%     ALL_PHASORS = [0; 0];
%     % ---
    
    
    % Главный цикл без прореживания:
    
    while (time + buf_dt) < full_time   % когда процесс сбора данных закончится
                                        % или заканчивается ("= full_time"),
                                        % буфер опросить уже не сможем
    
        % Имитируем опросы буфера мгновенных значений сигнала через интервалы
        % времени "buf_dt":
        time_prev = time;   % предыдущая метка времени опроса буфера
        time = time_prev + buf_dt;   % метка времени нового опроса
        
        % Мгновенные значения сигнала, накопленные за интервал времени между
        % двумя последовательными опросами буфера мгновенных значений:
        %
        % Выделяем метки времени:
%         t_stamps_raw = ...
%         t_all_raw( (t_all_raw >= time_prev) & (t_all_raw < time) );
%         % (наличие в одном случае строгого знака ("<"), а в другом - нестрогого
%         % (">="), гарантирует то, что все взятые из буфера данные уникальны;
%         % при этом нестрогий знак соответствует более ранней метке времени,
%         % иначе не заберём выборку с самой первой меткой времени (t = 0); кроме
%         % того, строгий знак, соответствующий более поздней метке времени,
%         % имитирует тот факт, что последняя взятая выборка должна появиться в
%         % буфере хотя бы на мгновение раньше момента времени опроса буфера)
        %
        % Так, как выше (закомментировано), должно быть в идеале. А
        % результаты нашего предварительного "прогона" данного кода
        % показывают, что из-за ошибок округления число выборок, взятое из
        % буфера мгновенных значений, может отличаться на 2 (чего не должно
        % быть при наличии в одном случае строгого знака, а в другом -
        % нестрогого (см. выше)), например:
        % [ min(each_buf_request), max(each_buf_request) ]
        % ans =
        %     29    31
        % Поэтому поступаем иначе: фиксируем метку времени ("t_first_new"),
        % которая будет соответствовать первой выборке, взятой при
        % очередном опросе буфера, и начинаем отсчёт с неё с шагом "dt";
        % затем обновляем значение "t_first_new":
        t_stamps_raw = t_first_new : dt : time;
        t_first_new = t_stamps_raw(end) + dt;
        %
        % Вычисляем значения сигнала, соответствующие этим меткам времени:
        sig = sig_model(t_stamps_raw, std_noise);
        %
        sig_dec = sig;   % чтобы можно было воспользоваться кодом,
                         % аналогичным коду для случая с прореживанием
                         % сигнала (см. выше)
        t_stamps_dec = t_stamps_raw;   % та же цель
        %
        % Сохраняем информацию о количестве мгновенных значений (дискретных
        % отсчётов) сигнала, взятых из буфера:
        buf_request_number = buf_request_number + 1;
        each_buf_request(buf_request_number) = numel(sig);
    
        % Формируем матрицу из двух строк, поскольку и заполнение буфера, и
        % поставку сигнала в функцию вычисления синхрофазоров осуществляем
        % в матричном виде:
        new_dec = [ sig_dec; t_stamps_dec ];
        
%         % --- ТОЛЬКО ДЛЯ ТЕСТИРОВАНИЯ: ---
%         ALL_SAMPLES = [ALL_SAMPLES, new_dec];
%         % ---
        
        % Проверяем, достаточно ли уже накоплено выборок для вычисления
        % первого синхрофазора, и - если да - производим все необходимые
        % вычисления:
        if t_stamps_dec(end) >= time_stamp_Nth

            % Определяем, сколько же выборок из буфера можем
            % присоединить для вычисления синхрофазоров (в пределе - "N-1",
            % т.к. для вычисления одного из синхрофазоров не хватало лишь
            % одной выборки):
            if flag_samp_attach
                samp_attach = round( (t_stamps_dec(1) - t_all(1)) / dt_decim );
                samp_attach = min( [samp_attach, N-1] );
                if samp_attach >= (N-1)
                    flag_samp_attach = false;   % это означает, что в буфере к этому моменту
                                                % должно быть накоплено достаточное количество
                                                % выборок, поэтому в дальнейшем
                                                % "flag_samp_attach = false"
                end
            else
                samp_attach = N-1;
            end
            
            % Присоединяем необходимое количество выборок из буфера и
            % рассчитываем синхрофазоры:
            samp_for_phasors = [ buf_samp_part(:, (end-samp_attach+1):end), new_dec ];
            new_phasors = Phasor_computation(samp_for_phasors, N, dt_decim, 0, aux_1, aux_2);
            %
            % ПРИМЕЧАНИЕ. В данном случае "dt_decim" эквивалентно "dt",
            % никакой ошибки здесь нет. См. выше:
            %
            % if decim_need   % если требуется прореживание
            %     dt_decim = dt * dec_factor;
            %     t_all = (dt_decim - dt) : dt_decim : full_time;
            % else
            %     dt_decim = dt;   % чтобы не выполнять эту проверку каждый раз там, где
            %     % требуется задать "dt"
            %     t_all = t_all_raw;
            % end
            
%             % --- ТОЛЬКО ДЛЯ ТЕСТИРОВАНИЯ: ---
%             ALL_PHASORS = [ALL_PHASORS, new_phasors];
%             % ---
            
            % Определяем количество полученных синхрофазоров:
            num_new_phasors = size(new_phasors, 2);
            
            % Обновляем общее количество рассчитанных синхрофазоров:
            num_phasors_computed_previous = num_phasors_computed;   % понадобится позже (см. ниже)
            num_phasors_computed = num_phasors_computed + num_new_phasors;
            
            % Определяем, достаточно ли уже ненулевых значений (под
            % "достаточно" подразумевается их количество, равное
            % "phasors_for_freq_track") накоплено в буфере синхрофазоров,
            % чтобы откорректировать все вновь поступившие синхрофазоры
            % "new_phasors" по факту вычисления частоты (если, конечно, для
            % каждого из синхрофазоров "new_phasors" будет достаточное
            % количество синхрофазоров ("phasors_for_freq_track") в
            % "будущем", чего мы не знаем наперёд):
            if flag_ph_attach
                
                % Определяем, сколько синхрофазоров не могут быть
                % откорректированы по факту вычисления частоты, и выделяем
                % сами эти синхрофазоры:
                num_phasors_diff = num_phasors_computed - phasors_for_freq_track;
                if num_phasors_diff < 1
                    % Ни один из вновь прибывших синхрофазоров не сумеем
                    % откорректировать, т.е. все они уже готовы:
                    num_phasors_ready = num_new_phasors;
                    phasors_ready = new_phasors;
                else
                    % Не сумеем откорректировать все синхрофазоры, кроме
                    % последних "num_phasors_diff":
                    num_phasors_ready = num_new_phasors - num_phasors_diff;
                    phasors_ready = new_phasors(:, 1:num_phasors_ready);
                end
                
                % Отдельно проверяем, следует ли нам в будущем (на
                % следующей итерации) заходить в эту ветвь условного
                % оператора ("if flag_ph_attach"):
                if num_phasors_diff >= 0
                    flag_ph_attach = false;
                end
                
                % Используем рассчитанные синхрофазоры для определения
                % значений синхрофазоров, соответствующих меткам времени
                % "t_GPS", а также погрешностей "TVE_GPS" и алгоритмических
                % задержек "delay_GPS":
                for k = 1 : num_phasors_ready
                    
                    % Разность между меткой времени очередного синхрофазора
                    % и следующей меткой времени из массива "t_GPS":
                    each_time_diff = phasors_ready(2, k) - next_t_GPS;
                    
                    if abs(each_time_diff) <= (dt_decim/2 + 1e-6)
                        
                        % Индекс текущей метки времени из массива "t_GPS":
                        num_ready_GPS = num_ready_GPS + 1;
                                                
                        % Синхрофазор, соответствующий метке времени
                        % "t_GPS":
                        Ph_c_GPS(num_ready_GPS) = phasors_ready(1, k) * ...
                        exp(-1i*0*each_time_diff);
                        %
                        % ПРИМЕЧАНИЕ. Реальная частота сигнала пока не
                        % известна, поэтому синхрофазор не можем повернуть,
                        % т.е. просто берём ближайший.
                    
                        % Погрешность вычисления синхрофазора:
                        [TVE_calc, ~, ~] = ...
                        Error_computation(Ph_true_GPS(num_ready_GPS), Ph_c_GPS(num_ready_GPS), ...
                        0, 0, 0, 0);
                        TVE_GPS(num_ready_GPS) = TVE_calc;
                        
                        % Алгоритмическая задержка:
                        delay_GPS(num_ready_GPS) = time - next_t_GPS;
                        
                        % Следующая метка времени из массива "t_GPS", за
                        % которой необходимо следить:
                        next_t_GPS = next_t_GPS + dt_GPS;
                    
                    end
                    %
                    % ПРИМЕЧАНИЕ. Поскольку частота и скорость изменения
                    % частоты для этой группы синхрофазоров
                    % "num_phasors_ready" не оценивались, соответствующие
                    % элементы векторов "f_c_GPS" и "deriv_c_GPS" пока
                    % остаются нулями. То же относится и к элементам
                    % векторов "df_GPS" и "df_dt_GPS".
                    
                end
                
                % Используем рассчитанные синхрофазоры для определения
                % значений синхрофазоров, соответствующих меткам времени
                % "t_all", а также погрешностей "TVE_all" и алгоритмических
                % задержек "delay_all":
                %
                % Индексы меток времени из массива "t_all":
                t_stamps_ind = num_ready_all + (1:num_phasors_ready);
                %
                % Синхрофазоры, соответствующие меткам времени "t_all":
                Ph_c_all(t_stamps_ind) = phasors_ready(1, :) * ...
                exp(-1i*0*dt_decim/2);
                %
                % ПРИМЕЧАНИЕ. Реальная частота сигнала пока не
                % известна, поэтому синхрофазор не можем повернуть,
                % т.е. просто берём ближайший.
                %
                % Погрешности вычисления синхрофазоров:
                [TVE_calc, ~, ~] = ...
                Error_computation(Ph_true_all(t_stamps_ind), Ph_c_all(t_stamps_ind), ...
                0, 0, 0, 0);
                TVE_all(t_stamps_ind) = TVE_calc;
                %
                % Алгоритмические задержки:
                delay_all(t_stamps_ind) = time - t_all(t_stamps_ind);
                
                % Обновляем информацию об общем количестве синхрофазоров,
                % готовых к передаче на верхний уровень иерархии:
                num_ready_all = num_ready_all + num_phasors_ready;
                
            end
            
            % Определяем, достаточно ли уже накоплено синхрофазоров для
            % оценки частоты (и коррекции синхрофазоров на этой основе), а
            % также "df/dt":
            if num_phasors_computed > (2*phasors_for_freq_track)
                
                % Смотрим, сколько рассчитанных синхрофазоров было
                % накоплено в буфере, и присоединяем максимум
                % "2*phasors_for_freq_track" синхрофазоров из буфера (общее
                % количество синхрофазоров, определяющих одно окно для
                % расчёта частоты и "df/dt", равно
                % "2*phasors_for_freq_track+1", т.е. для коррекции одного
                % из синхрофазоров не хватало всего лишь одного нового
                % значения):
                ph_attach = min( [num_phasors_computed_previous, 2*phasors_for_freq_track] );
                
                % Присоединяем необходимое количество синхрофазоров из
                % буфера, рассчитываем частоту и "df/dt", а также
                % корректируем синхрофазоры на основе информации о
                % фактической частоте:
                phasors_for_freq = [ buf_ph(:, (end-ph_attach+1):end), new_phasors ];
                [phasors_ready, f_calc, df_dt_calc] = ...
                Freq_estimation(phasors_for_freq, N, dt_decim, freq_alg, phasors_for_freq_track);
            
                % Определяем количество рассчитанных значений частоты
                % (совпадающее с количеством рассчитанных значений "df/dt",
                % а также с числом откорректированных синхрофазоров):
                num_phasors_ready = numel(f_calc);
            
                % Определяем значения синхрофазоров, частоты и скорости
                % изменения частоты, соответствующие меткам времени
                % "t_GPS", а также рассчитываем соответствующие погрешности
                % и алгоритмические задержки:
                for k = 1 : num_phasors_ready
                    
                    % Разность между меткой времени очередного синхрофазора
                    % и следующей меткой времени из массива "t_GPS":
                    each_time_diff = phasors_ready(2, k) - next_t_GPS;
                    
                    if abs(each_time_diff) <= (dt_decim/2 + 1e-6)
                        
                        % Индекс текущей метки времени из массива "t_GPS":
                        num_ready_GPS = num_ready_GPS + 1;
                                                
                        % Синхрофазор, соответствующий метке времени
                        % "t_GPS":
                        Ph_c_GPS(num_ready_GPS) = phasors_ready(1, k) * ...
                        exp(-1i*(2*pi*f_calc(k)-omega_n)*each_time_diff);
                    
                        % Значения частоты и скорости изменения частоты,
                        % соответствующие этой же метке времени:
                        f_c_GPS(num_ready_GPS) = f_calc(k);
                        deriv_c_GPS(num_ready_GPS) = df_dt_calc(k);
                        %
                        % ПРИМЕЧАНИЕ. Не используем никакую интерполяцию
                        % для значений частоты и скорости изменения
                        % частоты, а просто берём ближайшие рассчитанные
                        % значения (изменение частоты за интервал времени
                        % "dt_decim/2" должно быть очень мало).
                    
                        % Погрешности:
                        [TVE_calc, freq_err_calc, df_dt_err_calc] = ...
                        Error_computation(Ph_true_GPS(num_ready_GPS), Ph_c_GPS(num_ready_GPS), ...
                        f_true_GPS(num_ready_GPS), f_c_GPS(num_ready_GPS), deriv_true, deriv_c_GPS(num_ready_GPS));
                        TVE_GPS(num_ready_GPS) = TVE_calc;
                        df_GPS(num_ready_GPS) = freq_err_calc;
                        df_dt_GPS(num_ready_GPS) = df_dt_err_calc;
                        
                        % Алгоритмическая задержка:
                        delay_GPS(num_ready_GPS) = time - next_t_GPS;
                        
                        % Следующая метка времени из массива "t_GPS", за
                        % которой необходимо следить:
                        next_t_GPS = next_t_GPS + dt_GPS;
                    
                    end
                    
                end
                
                % Определяем значения синхрофазоров, частоты и скорости
                % изменения частоты, соответствующие меткам времени
                % "t_all", а также рассчитываем соответствующие погрешности
                % и алгоритмические задержки:
                %
                % Индексы меток времени из массива "t_all":
                t_stamps_ind = num_ready_all + (1:num_phasors_ready);
                %
                % Синхрофазоры, соответствующие меткам времени "t_all":
                Ph_c_all(t_stamps_ind) = phasors_ready(1, :) .* ...
                exp(-1i*(2*pi*f_calc-omega_n)*dt_decim/2);
                %
                % Значения частоты и скорости изменения частоты,
                % соответствующие этим же меткам времени:
                f_c_all(t_stamps_ind) = f_calc;
                deriv_c_all(t_stamps_ind) = df_dt_calc;
                %
                % Погрешности:
                [TVE_calc, freq_err_calc, df_dt_err_calc] = ...
                Error_computation(Ph_true_all(t_stamps_ind), Ph_c_all(t_stamps_ind), ...
                f_true_all(t_stamps_ind), f_c_all(t_stamps_ind), deriv_true, deriv_c_all(t_stamps_ind));
                TVE_all(t_stamps_ind) = TVE_calc;
                df_all(t_stamps_ind) = freq_err_calc;
                df_dt_all(t_stamps_ind) = df_dt_err_calc;
                %
                % Алгоритмические задержки:
                delay_all(t_stamps_ind) = time - t_all(t_stamps_ind);
                
                % Обновляем информацию об общем количестве синхрофазоров,
                % готовых к передаче на верхний уровень иерархии:
                num_ready_all = num_ready_all + num_phasors_ready;
                
            end
            %
            % ПРИМЕЧАНИЕ. Здесь тоже можно было бы ввести вспомогательную
            % логическую переменную, изменяющую своё значение, когда в
            % буфере появляется как минимум "2*phasors_for_freq_track"
            % синхрофазоров, чтобы не оценивать на каждой последующей
            % итерации, сколько же синхрофазоров необходимо присоединить из
            % буфера. Однако этого делать не будем, т.к. и так много
            % различных переменных.
            
            % Обновляем буфер синхрофазоров:
            buf_ph = Buffer_of_phasors(buf_ph, new_phasors, 5*N);
            
        end
        
        % Обновляем буфер прореженных мгновенных значений сигнала:
        buf_samp_part = Buffer_of_samples(buf_samp_part, new_dec, 2*N);
        
        % Строим графики действующих значений и фазовых углов
        % синхрофазоров, частоты и скорости изменения частоты, а также
        % погрешностей "TVE":
        if (  (time >= time_plot) || ((time + buf_dt) >= full_time)  )
            
            % Будем отображать на всех графиках не более чем "5*N"
            % последних точек данных:
            plot_all = min( [5*N, num_ready_all] );
            plot_GPS = min( [10, num_ready_GPS] );
            
            % Определяем индексы меток времени и сами метки времени:
            plot_all = (num_ready_all-plot_all+1):num_ready_all;
            t_plot_all = t_all(plot_all);
            plot_GPS = (num_ready_GPS-plot_GPS+1):num_ready_GPS;
            t_plot_GPS = t_GPS(plot_GPS);
            
            % Строим графики:
            %
            figure(handle);
            %
            % 1.
            %
            subplot(5,2,1);
            plot(  t_plot_all, abs(Ph_true_all(plot_all)), '.-r', ...
            t_plot_all, abs(Ph_c_all(plot_all)), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('Действ. знач., В');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            title('"Внутренние" вычисления:');
            %
            % 2.
            %
            subplot(5,2,2);
            plot(  t_plot_GPS, abs(Ph_true_GPS(plot_GPS)), '.-r', ...
            t_plot_GPS, abs(Ph_c_GPS(plot_GPS)), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('Действ. знач., В');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            title('"Внешние" вычисления ("привязанные" к GPS):');
            %
            % 3.
            %
            subplot(5,2,3);
            plot(  t_plot_all, angle(Ph_true_all(plot_all))*180/pi, '.-r', ...
            t_plot_all, angle(Ph_c_all(plot_all))*180/pi, '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('Фаза, град.');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            %
            % 4.
            %
            subplot(5,2,4);
            plot(  t_plot_GPS, angle(Ph_true_GPS(plot_GPS))*180/pi, '.-r', ...
            t_plot_GPS, angle(Ph_c_GPS(plot_GPS))*180/pi, '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('Фаза, град.');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            %
            % 5.
            %
            subplot(5,2,5);
            plot(  t_plot_all, f_true_all(plot_all), '.-r', ...
            t_plot_all, f_c_all(plot_all), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('Частота, Гц');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            %
            % 6.
            %
            subplot(5,2,6);
            plot(  t_plot_GPS, f_true_GPS(plot_GPS), '.-r', ...
            t_plot_GPS, f_c_GPS(plot_GPS), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('Частота, Гц');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            %
            % 7.
            %
            subplot(5,2,7);
            plot(  t_plot_all, deriv_true * ones(1, numel(plot_all)), '.-r', ...
            t_plot_all, deriv_c_all(plot_all), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('"df/dt", Гц/с');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            %
            % 8.
            %
            subplot(5,2,8);
            plot(  t_plot_GPS, deriv_true * ones(1, numel(plot_GPS)), '.-r', ...
            t_plot_GPS, deriv_c_GPS(plot_GPS), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('"df/dt", Гц/с');
            legend('Эталон', 'Расчёт',   'Location', 'Best');
            %
            % 9.
            %
            subplot(5,2,9);
            plot(  t_plot_all, ones(1, numel(plot_all)), '.-r', ...
            t_plot_all, TVE_all(plot_all), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('"TVE", %');
            legend('"TVE" = 1 %', 'Расчёт',   'Location', 'Best');
            %
            % 10.
            %
            subplot(5,2,10);
            plot(  t_plot_GPS, ones(1, numel(plot_GPS)), '.-r', ...
            t_plot_GPS, TVE_GPS(plot_GPS), '.-b'  );
            grid on; axis tight;
            xlabel('Время, с'); ylabel('"TVE", %');
            legend('"TVE" = 1 %', 'Расчёт',   'Location', 'Best');
            
            % Определяем момент времени, по истечении которого будем
            % обновлять все графики:
            time_plot = time_plot + time_plot_dt;
            
            % Небольшая пауза, чтобы рассмотреть графики:
            pause(3);
            
        end
    
    end
    
    
end


% Строим графики, отображающие все рассчитанные значения:
%
handle_new = figure;
set(gcf, 'Position', get(0, 'Screensize'));
figure(handle_new);
%
Ph_all_ind = find(Ph_c_all);   % игнорируем нулевые значения
freq_all_ind = find(f_c_all);   % игнорируем нулевые значения
Ph_GPS_ind = find(Ph_c_GPS);   % игнорируем нулевые значения
freq_GPS_ind = find(f_c_GPS);   % игнорируем нулевые значения
%
% 1.
%
subplot(5,2,1);
plot(  t_all(Ph_all_ind), abs(Ph_true_all(Ph_all_ind)), '.-r', ...
t_all(Ph_all_ind), abs(Ph_c_all(Ph_all_ind)), '.-b'  );
grid on; axis tight;
xlabel('Время, с'); ylabel('Действ. знач., В');
legend('Эталон', 'Расчёт',   'Location', 'Best');
title('ВСЕ "внутренние" вычисления:', 'fontweight','bold');
%
% 2.
%
subplot(5,2,2);
plot(  t_GPS(Ph_GPS_ind), abs(Ph_true_GPS(Ph_GPS_ind)), '.-r', ...
t_GPS(Ph_GPS_ind), abs(Ph_c_GPS(Ph_GPS_ind)), '.-b'  );
grid on; axis tight;
xlabel('Время, с'); ylabel('Действ. знач., В');
legend('Эталон', 'Расчёт',   'Location', 'Best');
title('ВСЕ "внешние" вычисления ("привязанные" к GPS):', 'fontweight','bold');
%
% 3.
%
subplot(5,2,3);
plot(  t_all(Ph_all_ind), angle(Ph_true_all(Ph_all_ind))*180/pi, '.-r', ...
t_all(Ph_all_ind), angle(Ph_c_all(Ph_all_ind))*180/pi, '.-b'  );
grid on; axis tight;
xlabel('Время, с'); ylabel('Фаза, град.');
legend('Эталон', 'Расчёт',   'Location', 'Best');
%
% 4.
%
subplot(5,2,4);
plot(  t_GPS(Ph_GPS_ind), angle(Ph_true_GPS(Ph_GPS_ind))*180/pi, '.-r', ...
t_GPS(Ph_GPS_ind), angle(Ph_c_GPS(Ph_GPS_ind))*180/pi, '.-b'  );
grid on; axis tight;
xlabel('Время, с'); ylabel('Фаза, град.');
legend('Эталон', 'Расчёт',   'Location', 'Best');
%
% 5.
%
subplot(5,2,5);
plot(  t_all(freq_all_ind), f_true_all(freq_all_ind), '.-r', ...
t_all(freq_all_ind), f_c_all(freq_all_ind), '.-b'  );
grid on; axis tight;
xlabel('Время, с'); ylabel('Частота, Гц');
legend('Эталон', 'Расчёт',   'Location', 'Best');
%
% 6.
%
subplot(5,2,6);
plot(  t_GPS(freq_GPS_ind), f_true_GPS(freq_GPS_ind), '.-r', ...
t_GPS(freq_GPS_ind), f_c_GPS(freq_GPS_ind), '.-b'  );
grid on; axis tight;
xlabel('Время, с'); ylabel('Частота, Гц');
legend('Эталон', 'Расчёт',   'Location', 'Best');
%
% 7.
%
subplot(5,2,7);
plot(  t_all(freq_all_ind), deriv_true * ones(1, numel(freq_all_ind)), '.-r', ...
t_all(freq_all_ind), deriv_c_all(freq_all_ind), '.-b'  );
grid on; axis tight;
xlabel('Время, с'); ylabel('"df/dt", Гц/с');
legend('Эталон', 'Расчёт',   'Location', 'Best');
%
% 8.
%
subplot(5,2,8);
plot(  t_GPS(freq_GPS_ind), deriv_true * ones(1, numel(freq_GPS_ind)), '.-r', ...
t_GPS(freq_GPS_ind), deriv_c_GPS(freq_GPS_ind), '.-b'  );
grid on; axis tight;
xlabel('Время, с'); ylabel('"df/dt", Гц/с');
legend('Эталон', 'Расчёт',   'Location', 'Best');
%
% 9.
%
subplot(5,2,9);
plot(  t_all(Ph_all_ind), ones(1, numel(Ph_all_ind)), '.-r', ...
t_all(Ph_all_ind), TVE_all(Ph_all_ind), '.-b'  );
grid on; axis tight;
xlabel('Время, с'); ylabel('"TVE", %');
legend('"TVE" = 1 %', 'Расчёт',   'Location', 'Best');
%
% 10.
%
subplot(5,2,10);
plot(  t_GPS(Ph_GPS_ind), ones(1, numel(Ph_GPS_ind)), '.-r', ...
t_GPS(Ph_GPS_ind), TVE_GPS(Ph_GPS_ind), '.-b'  );
grid on; axis tight;
xlabel('Время, с'); ylabel('"TVE", %');
legend('"TVE" = 1 %', 'Расчёт',   'Location', 'Best');