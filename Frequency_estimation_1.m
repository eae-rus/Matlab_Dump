% %% Алгоритмы вычисления частоты
% %% Модели сигналов и вспомогательная информация
% 
% %%
% % Амплитуда:
% A = 100 * sqrt(2);
% %%
% % Частоты:
% 
% f1 = 50;
% f = 52;
% 
% %%
% % Начальная фаза:
% 
% fi = pi/4;
% 
% %%
% % Число выборок на период:
% 
% N = 48;
% 
% % Иммитируем прореживание сигнала из выборок, полученных с более высокой
% % скоростью оцифровки
% %%
% % Время дискретизации 
% 
% dt = (1/f1)/N;
% 
% 
% %%
% % Сигналы в виде handle функции
% 
% X = @(n) A * cos(2*pi*f*n*dt + fi);
% 
% %%
% % Задаем начальные значения, для "левой" пары выборок
% 
% Un1=0;
% Un=0;
% 
% %%
% % Задаем начальный индекс для левой граничной точки (первая выборка)
% 
% Z=0;
% 
% %%
% % Задаем начальное значение периода сигнала (Предполагаем, что мы не знаем
% % его.
% 
% T = 0;
% 
% %%
% % Цикл расчета:
% % Возьмем 20 полупериодов сигнала.
% 
% f_measurement=zeros(1,480);
% 
% %% Непосредственно цикл
% % Пришлось взять while с счетчиком, ибо по другому организовать скачки по 
% % переменной не получается. 
% 
% % Начальное значение счетчика по выборкам.
% k = 0;
% 
% m = 1;
% while k < N*10
%     %%
%     % Сравниваем два соседних значения (при переходе через 0 отношение соседних значений отрицательно)
%     
%     if ((X(k))/(X(k+1)))<0
%         %%
%         % Присваиваем значения для "правой" пары выборок
%         m=m+1;
%         Um1 = X(k+1);
%         Um = X(k);
%         %%
%         % Вычисляем период сигнала, с коррекцией на переходных участках
%         
%         T(m) = (((k+1)-Z)+(Un1/(Un1-Un))-(Um1/(Um1-Um)))*dt;
%         
%         % Значение частоты для каждого перехода через 0.
%         
%         f_alg(m) = 1/(2*T(m));
%         %%
%         % Присваиваем значения "правой" пары точек, для другой пары,
%         % которая при следующем цикле расчета станет "левой"парой.
%         
%         Un1=Um1;
%         Un=Um;
%         %%
%         % Перезаписываем начальный индекс для левой начальной точки.
%         
%         Z=k+1;
%        
%        
%         %% 
%         % Отстраиваемся от возможных колебаний в районе 0 (скачок на
%         % четверть периода, -1 потому что далее мы ее добавим)
%         
%         k=k+(N/4)-1;
%         
%         %%
%         % Заполняяем недостающие элементы матрицы частот, для того, чтобы 
%         % не вводить новую переменную, а использовать k.
%         
%         f_measurement(k-(N/4)-1:1:k) = 1/(2*T(m));
%         
%     end
%      %%
%         % Вычисляем частоту:
%         f_measurement(k+1) = 1/(2*T(m));
%        
%         k=k+1;
%   
% 
% end;
% 
% %% 
% % Алгоритм ведет себя странно если изменять значение реальной частоты от 48 до 52, но в целом работает не плохо для неизменяющегося сигнала.
% 
% figure, subplot(2,1,1); plot(X(1:480)); grid on;
%             title('Сигнал');
%             xlabel('Номер выборки');
%             ylabel('Амплитуда');
%         subplot(2,1,2); plot(f_measurement); grid on;
%             title('Вычисленная частота');
%             xlabel('Номер выборки');
%             ylabel('Частота (Гц)');
%             
% % Странную форму графика объяется не такой уж большой частотой 
% % дискретизации.           
% %%            
% % Усредняем значениz частот, считаем первые два значения Inf и NaN временем
% % загрузки алгоритма.
% f_mean=zeros(1,15);
% for k=3:17
% f_mean(k-2)=(sum(f_alg(3:k)))/(k-2);
% end
% 
% %%
% % Построим график
% 
%  figure,    plot(1:15,f_mean,1:15,(ones(1,15)*f)); grid on;
%             ylim( [51.999, 52.001] );
%             title('График усредненных частот');
%             xlabel('Колличество усредненных полупериодов');
%             ylabel('Частота');
%             
% %% Косинусный фильтр.
% 
% Sign_withcosine=Cosine_filter(X(0:N*10), N, 2);
% 
% % Для неизменяющегося значения выборок одинаковы
% 
% figure,     plot(1:481,X(0:((N*10))),1:481,Sign_withcosine); grid on;
%             title('График применения косинусного фильтра');
%             xlabel('Номер выборки');
%             ylabel('Значение сигнала');
%             legend( 'Сигнал без фильтра', 'Сигнал с фильтром', 'Location', 'Best');
%             
% % На первый взгляд применение фильтра для такого сигнала пользы не
% % принесет, проверим так ли это:
% 
% %%
% % Задаем начальные значения, для "левой" пары выборок
% 
% Un1=0;
% Un=0;
% 
% %%
% % Задаем начальный индекс для левой граничной точки (первая выборка)
% 
% Z=0;
% 
% %%
% % Задаем начальное значение периода сигнала (Предполагаем, что мы не знаем
% % его.
% 
% T = 0;
% 
% %%
% % Цикл расчета:
% % Возьмем 20 полупериодов сигнала.
% 
% f_measurement_cosine=zeros(1,480);
% 
% %% Непосредственно цикл:
% 
% % Начальное значение счетчика по выборкам.
% k = 1;
% 
% m = 1;
% while k < N*10+1
%     %%
%     % Сравниваем два соседних значения (при переходе через 0 отношение соседних значений отрицательно)
%     
%     if ((Sign_withcosine(k))/(Sign_withcosine(k+1)))<0
%         %%
%         % Присваиваем значения для "правой" пары выборок
%         m=m+1;
%         Um1 =Sign_withcosine(k+1);
%         Um = Sign_withcosine(k);
%         %%
%         % Вычисляем период сигнала, с коррекцией на переходных участках
%         
%         T(m) = (((k+1)-Z)+(Un1/(Un1-Un))-(Um1/(Um1-Um)))*dt;
%         
%         % Значение частоты для каждого перехода через 0.
%         
%         f_alg_cosine(m) = 1/(2*T(m));
%         %%
%         % Присваиваем значения "правой" пары точек, для другой пары,
%         % которая при следующем цикле расчета станет "левой"парой.
%         
%         Un1=Um1;
%         Un=Um;
%         %%
%         % Перезаписываем начальный индекс для левой начальной точки.
%         
%         Z=k+1;
%        
%        
%         %% 
%         % Отстраиваемся от возможных колебаний в районе 0 (скачок на
%         % четверть периода, -1 потому что далее мы ее добавим)
%         
%         k=k+(N/4)-1;
%         
%         %%
%         % Заполняяем недостающие элементы матрицы частот, для того, чтобы 
%         % не вводить новую переменную, а использовать k.
%         
%         f_measurement_cosine(k-(N/4)-1:1:k) = 1/(2*T(m));
%         
%     end
%      %%
%         % Вычисляем частоту:
%         f_measurement_cosine(k) = 1/(2*T(m));
%        
%         k=k+1;
%   
% 
% end;
% 
% %% Построим графики
% 
% figure, subplot(2,1,1); plot(Sign_withcosine); grid on;
%             title('Сигнал с фильтром');
%             xlabel('Номер выборки');
%             ylabel('Амплитуда');
%         subplot(2,1,2); plot(f_measurement_cosine); grid on;
%             title('Вычисленная частота');
%             xlabel('Номер выборки');
%             ylabel('Частота (Гц)');
%             
% % Косинусный фильтр дал хороший результат, небольшой "промах" связан с 
% % тем, что в начале сигнала, мы принимаем его таким же как и без фильтра, 
% % в результате получается "скачок" увеличивающий период. Для реального 
% % сигнала такая ошибка не существенна, так как мы используем боле широкий 
% % диапазон выборок "влево".  
% %%            
% % Усредняем значениz частот, считаем первые два значения Inf и NaN временем
% % загрузки алгоритма.
% 
% f_mean_cosine=zeros(1,15);
% for k=5:19
% f_mean_cosine(k-4)=(sum(f_alg_cosine(5:k)))/(k-4);
% end
% 
% %%
% % Построим график
% 
%  figure,    plot(1:15,f_mean_cosine,1:15,(ones(1,15)*f)); grid on;
%             ylim( [51.999, 52.001] );
%             title('График усредненных частот');
%             xlabel('Колличество усредненных полупериодов');
%             ylabel('Частота');
%             
% %% Оценим скорость измененния частоты
% 
% % Интервал измерения частоты
% delta_t=0.02;
% DF(1:143)=0;
% DF(433:481)=0;
% for k=144:(N*10-48)
%     
% DF(k)=-(f_measurement_cosine(k-48)-f_measurement_cosine(k+48))/(2*delta_t);
% 
% end
% 
% %% 
% % Построим график
% 
% figure, subplot(3,1,1); plot(Sign_withcosine); grid on;
%             title('Сигнал с фильтром');
%             xlabel('Номер выборки');
%             ylabel('Амплитуда');
%         subplot(3,1,2); plot(f_measurement_cosine); grid on;
%             ylim( [51.999, 52.001] );
%             title('Вычисленная частота');
%             xlabel('Номер выборки');
%             ylabel('Частота (Гц)');
%         subplot(3,1,3); plot(DF); grid on;
%             title('Скорость изменения частоты');
%             xlabel('Номер выборки');
%             ylabel('Изменение частоты (Гц)');
%             
% % В отброшенных слева и справа выбороках скорость изменения частоты не определяется, для реального
% % сигнала такого не будет, сам алгоритм подвирает, наверно надо брать
% % поменьше интервал или усреднять больше точек.
% 
% clear all;

%% Теперь осуществим алгоритм для частоты дискретизации 128 выборок за период
%% Модели сигналов и вспомогательная информация

%%
% Амплитуда:
A = 100 * sqrt(2);

%%
% Частоты:

f1 = 50;
f = 52;

%%
% Начальная фаза:

fi = pi/4;

%%
% Число выборок на период:

N = 128;

% Иммитируем прореживание сигнала из выборок, полученных с более высокой
% скоростью оцифровки
%%
% Время дискретизации 

dt = (1/f1)/N;


%%
% Сигналы в виде handle функции:

X = @(n) A * cos(2*pi*f*n*dt + fi);

%%
% Задаем начальные значения, для "левой" пары выборок

Un1=0;
Un=0;

%%
% Задаем начальный индекс для левой граничной точки (первая выборка)

Z=0;

%%
% Задаем начальное значение периода сигнала (Предполагаем, что мы не знаем
% его.

T = 0;

%%
% Цикл расчета:
% Возьмем 20 полупериодов сигнала.

f_measurement=zeros(1,N*10);

%% Непосредственно цикл
% Пришлось взять while с счетчиком, ибо по другому организовать скачки по 
% переменной не получается. 

% Начальное значение счетчика по выборкам.
k = 0;

m = 1;
while k < N*10
    %%
    % Сравниваем два соседних значения (при переходе через 0 произведение соседних значений отрицательно)
    
    if ((X(k))*(X(k+1)))<0
        %%
        % Присваиваем значения для "правой" пары выборок
        m=m+1;
        Um1 = X(k+1);
        Um = X(k);
        %%
        % Вычисляем период сигнала, с коррекцией на переходных участках
        
        T(m) = (((k+1)-Z)+(Un1/(Un1-Un))-(Um1/(Um1-Um)))*dt;
        
        % Значение частоты для каждого перехода через 0.
        
        f_alg(m) = 1/(2*T(m));
        %%
        % Присваиваем значения "правой" пары точек, для другой пары,
        % которая при следующем цикле расчета станет "левой"парой.
        
        Un1=Um1;
        Un=Um;
        %%
        % Перезаписываем начальный индекс для левой начальной точки.
        
        Z=k+1;
       
       
        %% 
        % Отстраиваемся от возможных колебаний в районе 0 (скачок на
        % четверть периода, -1 потому что далее мы ее добавим)
        
        k=k+(N/4)-1;
        
        %%
        % Заполняяем недостающие элементы матрицы частот, для того, чтобы 
        % не вводить новую переменную, а использовать k.
        
        f_measurement(k-(N/4)-1:1:k) = 1/(2*T(m));
        
    end
     %%
        % Вычисляем частоту:
        f_measurement(k+1) = 1/(2*T(m));
       
        k=k+1;
  

end;

%% Построим график

figure, subplot(2,1,1); plot(X(1:N*10)); grid on;
            title('Сигнал');
            xlabel('Номер выборки');
            ylabel('Амплитуда');
        subplot(2,1,2); plot(f_measurement); grid on;
            title('Вычисленная частота');
            xlabel('Номер выборки');
            ylabel('Частота (Гц)');
            
% А вот при такой частоте дискретизации, частота сигнала определяется очень точно.           
%%            
% Усредняем значениz частот, считаем первые два значения Inf и NaN временем
% загрузки алгоритма.
f_mean=zeros(1,15);
for k=3:17
f_mean(k-2)=(sum(f_alg(3:k)))/(k-2);
end

%%
% Построим график

 figure,    plot(1:15,f_mean,1:15,(ones(1,15)*f)); grid on;
            ylim( [51.999, 52.001] );
            title('График усредненных частот');
            xlabel('Колличество усредненных полупериодов');
            ylabel('Частота');
% Как и ожидалось график усредненных частот ложится еще ближе к истинной частоте.

%% Косинусный фильтр.

Sign_withcosine=Cosine_filter(X(0:N*10), N, 2);

% Для неизменяющегося значения выборок одинаковы

figure,     plot(1:(N*10)+1,X(0:((N*10))),1:(N*10)+1,Sign_withcosine); grid on;
            title('График применения косинусного фильтра');
            xlabel('Номер выборки');
            ylabel('Значение сигнала');
            legend( 'Сигнал без фильтра', 'Сигнал с фильтром', 'Location', 'Best');
            
% На первый взгляд применение фильтра для такого сигнала пользы не
% принесет, проверим так ли это:

%%
% Задаем начальные значения, для "левой" пары выборок

Un1=0;
Un=0;

%%
% Задаем начальный индекс для левой граничной точки (первая выборка)

Z=0;

%%
% Задаем начальное значение периода сигнала (Предполагаем, что мы не знаем
% его.

T = 0;

%%
% Цикл расчета:
% Возьмем 20 полупериодов сигнала.

f_measurement_cosine=zeros(1,N*10);

%% Непосредственно цикл:

% Начальное значение счетчика по выборкам.
k = 1;

m = 1;
while k < N*10+1
    %%
    % Сравниваем два соседних значения (при переходе через 0 отношение соседних значений отрицательно)
    
    if ((Sign_withcosine(k))/(Sign_withcosine(k+1)))<0
        %%
        % Присваиваем значения для "правой" пары выборок
        m=m+1;
        Um1 =Sign_withcosine(k+1);
        Um = Sign_withcosine(k);
        %%
        % Вычисляем период сигнала, с коррекцией на переходных участках
        
        T(m) = (((k+1)-Z)+(Un1/(Un1-Un))-(Um1/(Um1-Um)))*dt;
        
        % Значение частоты для каждого перехода через 0.
        
        f_alg_cosine(m) = 1/(2*T(m));
        %%
        % Присваиваем значения "правой" пары точек, для другой пары,
        % которая при следующем цикле расчета станет "левой"парой.
        
        Un1=Um1;
        Un=Um;
        %%
        % Перезаписываем начальный индекс для левой начальной точки.
        
        Z=k+1;
       
       
        %% 
        % Отстраиваемся от возможных колебаний в районе 0 (скачок на
        % четверть периода, -1 потому что далее мы ее добавим)
        
        k=k+(N/4)-1;
        
        %%
        % Заполняяем недостающие элементы матрицы частот, для того, чтобы 
        % не вводить новую переменную, а использовать k.
        
        f_measurement_cosine(k-(N/4)-1:1:k) = 1/(2*T(m));
        
    end
     %%
        % Вычисляем частоту:
        f_measurement_cosine(k) = 1/(2*T(m));
       
        k=k+1;
  

end;

%% Построим графики

figure, subplot(2,1,1); plot(Sign_withcosine); grid on;
            title('Сигнал с фильтром');
            xlabel('Номер выборки');
            ylabel('Амплитуда');
        subplot(2,1,2); plot(f_measurement_cosine); grid on;
            title('Вычисленная частота');
            xlabel('Номер выборки');
            ylabel('Частота (Гц)');
            
 % Для сигнала с косинусным фильтром, увеличение частоты дискретизации
 % ничего не меняет.
 
%%            
% Усредняем значениz частот, считаем первые два значения Inf и NaN временем
% загрузки алгоритма.

f_mean_cosine=zeros(1,15);
for k=5:19
f_mean_cosine(k-4)=(sum(f_alg_cosine(5:k)))/(k-4);
end

%%
% Построим график

 figure,    plot(1:15,f_mean_cosine,1:15,(ones(1,15)*f)); grid on;
            ylim( [51.999, 52.001] );
            title('График усредненных частот');
            xlabel('Колличество усредненных полупериодов');
            ylabel('Частота');

 % Для сигнала с косинусным фильтром, увеличение частоты дискретизации
 % ничего не меняет.

%% Оценим скорость измененния частоты

% Интервал измерения частоты
delta_t=0.02;
DF(1:383)=0;
DF(1153:1281)=0;
for k=384:(N*10-128)
    
DF(k)=-(f_measurement_cosine(k-128)-f_measurement_cosine(k+128))/(2*delta_t);

end

%% 
% Построим график

figure, subplot(3,1,1); plot(Sign_withcosine); grid on;
            title('Сигнал с фильтром');
            xlabel('Номер выборки');
            ylabel('Амплитуда');
        subplot(3,1,2); plot(f_measurement_cosine); grid on;
            ylim( [51.999, 52.001] );
            title('Вычисленная частота');
            xlabel('Номер выборки');
            ylabel('Частота (Гц)');
        subplot(3,1,3); plot(DF); grid on;
            title('Скорость изменения частоты');
            xlabel('Номер выборки');
            ylabel('Изменение частоты (Гц)');
            
% В отброшенных слева и справа выбороках скорость изменения частоты не определяется, для реального
% сигнала такого не будет, сам алгоритм подвирает, наверно надо брать
% поменьше интервал или усреднять больше точек.